<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Syr's M+ Score Goal Helper</title>
<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
:root {
  --bg-primary: #1a1b1e;
  --bg-secondary: #25262b;
  --bg-tertiary: #2c2d33;
  --bg-card: #2c2d33;
  --bg-input: #32333a;
  --bg-hover: #373840;
  --text-primary: #e4e5e7;
  --text-secondary: #a1a2a6;
  --text-muted: #6d6e73;
  --border: #3a3b42;
  --accent: #5b9cf5;
  --accent-hover: #4a8be4;
  --accent-dim: rgba(91,156,245,0.15);
  --success: #4ade80;
  --warning: #fbbf24;
  --danger: #f87171;
  --star1: #94a3b8;
  --star2: #fbbf24;
  --star3: #f97316;
  --shadow: 0 4px 24px rgba(0,0,0,0.3);
  --radius: 10px;
  --radius-sm: 6px;
  --transition: 0.2s ease;
}
[data-theme="light"] {
  --bg-primary: #f0f1f3;
  --bg-secondary: #ffffff;
  --bg-tertiary: #f7f8fa;
  --bg-card: #ffffff;
  --bg-input: #edeef0;
  --bg-hover: #e5e6e8;
  --text-primary: #1a1b1e;
  --text-secondary: #5c5d63;
  --text-muted: #9a9ba0;
  --border: #d8d9dd;
  --accent: #3b7de0;
  --accent-hover: #2a6ccf;
  --accent-dim: rgba(59,125,224,0.1);
  --shadow: 0 4px 24px rgba(0,0,0,0.08);
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Outfit', sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  min-height: 100vh;
  transition: background var(--transition), color var(--transition);
}
.mono { font-family: 'JetBrains Mono', monospace; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--bg-primary); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
.container { max-width: 1100px; margin: 0 auto; padding: 0 20px; }
.header { padding: 24px 0; border-bottom: 1px solid var(--border); margin-bottom: 32px; }
.header-inner { display: flex; align-items: center; justify-content: space-between; }
.logo { display: flex; align-items: center; gap: 12px; }
.logo-icon {
  width: 36px; height: 36px; border-radius: 8px;
  background: linear-gradient(135deg, var(--accent), #8b5cf6);
  display: flex; align-items: center; justify-content: center;
  font-weight: 700; font-size: 16px; color: #fff;
}
.logo h1 { font-size: 20px; font-weight: 600; letter-spacing: -0.3px; }
.logo span { color: var(--accent); }
.header-actions { display: flex; align-items: center; gap: 12px; }
.theme-toggle {
  width: 52px; height: 28px; border-radius: 14px;
  background: var(--bg-input); border: 1px solid var(--border);
  cursor: pointer; position: relative; transition: all var(--transition);
}
.theme-toggle::after {
  content: ''; position: absolute; width: 22px; height: 22px;
  border-radius: 50%; background: var(--accent);
  top: 2px; left: 2px; transition: transform var(--transition);
}
.theme-toggle.light::after { transform: translateX(24px); }
.theme-toggle-label { font-size: 12px; color: var(--text-muted); }
.btn {
  padding: 10px 20px; border-radius: var(--radius-sm);
  font-family: 'Outfit', sans-serif; font-weight: 500; font-size: 14px;
  border: none; cursor: pointer; transition: all var(--transition);
  display: inline-flex; align-items: center; gap: 8px;
}
.btn-primary { background: var(--accent); color: #fff; }
.btn-primary:hover { background: var(--accent-hover); transform: translateY(-1px); }
.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
.btn-secondary { background: var(--bg-input); color: var(--text-primary); border: 1px solid var(--border); }
.btn-secondary:hover { background: var(--bg-hover); }
.btn-sm { padding: 6px 14px; font-size: 13px; }
.btn-ghost { background: transparent; color: var(--text-secondary); padding: 6px 10px; }
.btn-ghost:hover { color: var(--text-primary); background: var(--bg-hover); }
.btn-danger { background: transparent; color: var(--danger); }
.btn-danger:hover { background: rgba(248,113,113,0.1); }
.input-group { display: flex; flex-direction: column; gap: 6px; position: relative; }
.input-group label { font-size: 13px; font-weight: 500; color: var(--text-secondary); }
.input, select {
  padding: 10px 14px; border-radius: var(--radius-sm);
  background: var(--bg-input); border: 1px solid var(--border);
  color: var(--text-primary); font-family: 'Outfit', sans-serif;
  font-size: 14px; transition: all var(--transition); outline: none; width: 100%;
}
.input:focus, select:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-dim); }
select {
  cursor: pointer; appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%236d6e73' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat; background-position: right 12px center; padding-right: 32px;
}
.autocomplete-dropdown {
  position: absolute; top: 100%; left: 0; right: 0; z-index: 100;
  background: var(--bg-card); border: 1px solid var(--border);
  border-radius: var(--radius-sm); margin-top: 4px;
  max-height: 200px; overflow-y: auto; box-shadow: var(--shadow);
}
.autocomplete-item {
  padding: 8px 14px; cursor: pointer; font-size: 14px;
  color: var(--text-primary); transition: background 0.1s;
}
.autocomplete-item:hover, .autocomplete-item.active { background: var(--accent-dim); color: var(--accent); }
.autocomplete-item .realm-slug { font-size: 11px; color: var(--text-muted); margin-left: 6px; }
.autocomplete-item mark { background: transparent; color: var(--accent); font-weight: 600; }
.card {
  background: var(--bg-card); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 24px; transition: all var(--transition);
}
.search-grid { display: grid; grid-template-columns: 1fr 1fr 140px 120px; gap: 12px; align-items: end; }
.target-row { display: grid; grid-template-columns: 200px 1fr; gap: 12px; align-items: end; margin-top: 16px; }
.tabs { display: flex; gap: 4px; margin-bottom: 24px; }
.tab {
  padding: 10px 20px; border-radius: var(--radius-sm);
  background: transparent; color: var(--text-secondary);
  font-family: 'Outfit', sans-serif; font-weight: 500;
  font-size: 14px; border: none; cursor: pointer; transition: all var(--transition);
}
.tab:hover { color: var(--text-primary); background: var(--bg-hover); }
.tab.active { background: var(--accent); color: #fff; }
.dungeon-row {
  display: flex; align-items: center; gap: 16px;
  padding: 14px 16px; border-radius: var(--radius-sm);
  background: var(--bg-tertiary); border: 1px solid var(--border);
  margin-bottom: 8px; transition: all var(--transition);
}
.dungeon-row:hover { border-color: var(--accent); }
.dungeon-thumb {
  width: 48px; height: 48px; border-radius: 8px;
  object-fit: cover; flex-shrink: 0; border: 2px solid var(--border); background: var(--bg-input);
}
.dungeon-info { flex: 1; min-width: 0; }
.dungeon-name { font-weight: 600; font-size: 15px; margin-bottom: 2px; }
.dungeon-meta { font-size: 12px; color: var(--text-muted); display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
.dungeon-score-col { text-align: right; min-width: 80px; }
.dungeon-score { font-size: 20px; font-weight: 700; font-family: 'JetBrains Mono', monospace; }
.dungeon-score-label { font-size: 11px; color: var(--text-muted); }
.star-badge {
  display: inline-flex; align-items: center; gap: 3px;
  padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600;
}
.star-1 { background: rgba(148,163,184,0.15); color: var(--star1); }
.star-2 { background: rgba(251,191,36,0.15); color: var(--star2); }
.star-3 { background: rgba(249,115,22,0.15); color: var(--star3); }
.key-level-badge {
  display: inline-flex; padding: 2px 8px; border-radius: 10px;
  font-size: 12px; font-weight: 600; background: var(--accent-dim); color: var(--accent);
  font-family: 'JetBrains Mono', monospace;
}
.affix-badges { display: flex; gap: 4px; flex-wrap: wrap; }
.affix-badge {
  padding: 1px 6px; border-radius: 4px; font-size: 10px;
  background: var(--bg-hover); color: var(--text-secondary); border: 1px solid var(--border);
}
.time-info { font-size: 12px; color: var(--text-muted); font-family: 'JetBrains Mono', monospace; }
.constraints-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 16px; }
.dungeon-checkboxes { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 8px; }
.checkbox-label {
  display: flex; align-items: center; gap: 8px;
  font-size: 13px; cursor: pointer; color: var(--text-secondary);
  padding: 4px 8px; border-radius: var(--radius-sm); transition: all var(--transition);
}
.checkbox-label:hover { background: var(--bg-hover); color: var(--text-primary); }
.checkbox-label input { accent-color: var(--accent); }
.keystone-grid { display: grid; grid-template-columns: 1fr 80px 60px; gap: 8px; align-items: center; margin-bottom: 6px; }
.path-summary {
  display: flex; gap: 16px; align-items: center;
  padding: 16px; background: var(--accent-dim);
  border-radius: var(--radius-sm); margin-bottom: 16px;
  border: 1px solid rgba(91,156,245,0.2);
}
.path-stat { text-align: center; }
.path-stat-value { font-size: 24px; font-weight: 700; color: var(--accent); font-family: 'JetBrains Mono', monospace; }
.path-stat-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
.path-divider { width: 1px; height: 40px; background: var(--border); }
.score-delta { color: var(--success); }
.saved-list { display: flex; flex-direction: column; gap: 8px; }
.saved-item {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 14px; border-radius: var(--radius-sm);
  background: var(--bg-tertiary); border: 1px solid var(--border);
  cursor: pointer; transition: all var(--transition);
}
.saved-item:hover { border-color: var(--accent); }
.saved-item-name { font-weight: 500; font-size: 14px; }
.saved-item-meta { font-size: 12px; color: var(--text-muted); }
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.6);
  display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 20px;
}
.modal {
  background: var(--bg-card); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 32px;
  max-width: 560px; width: 100%; max-height: 80vh; overflow-y: auto;
}
.modal h2 { font-size: 20px; margin-bottom: 16px; }
.modal p { font-size: 14px; color: var(--text-secondary); line-height: 1.7; margin-bottom: 12px; }
.loading-spinner {
  width: 32px; height: 32px; border: 3px solid var(--border);
  border-top-color: var(--accent); border-radius: 50%;
  animation: spin 0.8s linear infinite; margin: 40px auto;
}
@keyframes spin { to { transform: rotate(360deg); } }
.error-msg {
  padding: 12px 16px; border-radius: var(--radius-sm);
  background: rgba(248,113,113,0.1); border: 1px solid rgba(248,113,113,0.2);
  color: var(--danger); font-size: 14px;
}
.info-msg {
  padding: 12px 16px; border-radius: var(--radius-sm);
  background: var(--accent-dim); border: 1px solid rgba(91,156,245,0.2);
  color: var(--accent); font-size: 13px;
}
.current-score-card { display: flex; align-items: center; gap: 20px; padding: 20px; margin-bottom: 24px; }
.avatar { width: 64px; height: 64px; border-radius: 12px; border: 2px solid var(--accent); object-fit: cover; }
.char-details { flex: 1; }
.char-name { font-size: 22px; font-weight: 700; }
.char-realm { font-size: 13px; color: var(--text-muted); }
.char-class { font-size: 13px; color: var(--text-secondary); margin-top: 2px; }
.current-score-display { text-align: right; }
.current-score-num {
  font-size: 36px; font-weight: 700; font-family: 'JetBrains Mono', monospace;
  background: linear-gradient(135deg, var(--accent), #8b5cf6);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.current-score-label { font-size: 12px; color: var(--text-muted); }
.section { margin-bottom: 32px; }
.section-title {
  font-size: 16px; font-weight: 600; margin-bottom: 16px;
  display: flex; align-items: center; gap: 8px;
}
.section-title .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent); }
.toggle-row { display: flex; align-items: center; gap: 12px; margin-top: 16px; margin-bottom: 8px; }
.toggle-label { font-size: 14px; font-weight: 500; }
.season-badge {
  display: inline-flex; align-items: center; gap: 6px;
  padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 500;
  background: var(--accent-dim); color: var(--accent); border: 1px solid rgba(91,156,245,0.2);
}
.footer {
  margin-top: 48px; padding: 24px 0; border-top: 1px solid var(--border);
  text-align: center; font-size: 12px; color: var(--text-muted);
}
.footer a { color: var(--accent); text-decoration: none; cursor: pointer; }
.footer a:hover { text-decoration: underline; }
@media (max-width: 768px) {
  .search-grid { grid-template-columns: 1fr 1fr; }
  .target-row { grid-template-columns: 1fr; }
  .constraints-grid { grid-template-columns: 1fr; }
  .dungeon-checkboxes { grid-template-columns: 1fr; }
  .path-summary { flex-wrap: wrap; }
  .header-inner { flex-wrap: wrap; gap: 12px; }
  .dungeon-row { flex-wrap: wrap; }
}
@keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
.fade-in { animation: fadeIn 0.3s ease forwards; }
</style>
</head>
<body data-theme="dark">
<div id="app"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<script type="text/babel">
const { useState, useEffect, useCallback, useRef, useMemo } = React;

const REGIONS = [
  { value: 'us', label: 'US' },
  { value: 'eu', label: 'EU' },
  { value: 'kr', label: 'KR' },
  { value: 'tw', label: 'TW' },
];

// Small offline fallback for realms so autocomplete works when the page
// is opened from file:// (no CORS-enabled fetch). This is a minimal
// list ‚Äî raider.io will still be queried when available.
const FALLBACK_REALMS = {
  us: [
    { name: 'Stormrage', slug: 'stormrage' },
    { name: 'Sargeras', slug: 'sargeras' },
    { name: 'Proudmoore', slug: 'proudmoore' },
    { name: 'Tichondrius', slug: 'tichondrius' },
  ],
  eu: [
    { name: 'Silvermoon', slug: 'silvermoon' },
    { name: 'Ragnaros', slug: 'ragnaros' },
    { name: 'Draenor', slug: 'draenor' },
  ],
  kr: [ { name: 'Azshara', slug: 'azshara' } ],
  tw: [ { name: 'Illidan', slug: 'illidan' } ],
};

// Fallback dungeons ‚Äî these only matter if the API returns zero runs for a character
const FALLBACK_DUNGEONS = [
  { slug: 'ara-kara-city-of-echoes', name: 'Ara-Kara, City of Echoes', short: 'ARA', timer: 1920 },
  { slug: 'the-dawnbreaker', name: 'The Dawnbreaker', short: 'DAWN', timer: 2040 },
  { slug: 'operation-floodgate', name: 'Operation: Floodgate', short: 'FLOOD', timer: 1920 },
  { slug: 'priory-of-the-sacred-flame', name: 'Priory of the Sacred Flame', short: 'PSF', timer: 2100 },
  { slug: 'halls-of-atonement', name: 'Halls of Atonement', short: 'HOA', timer: 1920 },
  { slug: 'tazavesh-streets-of-wonder', name: 'Tazavesh: Streets of Wonder', short: 'STREETS', timer: 2400 },
  { slug: 'tazavesh-soleahs-gambit', name: "Tazavesh: So'leah's Gambit", short: 'GAMBIT', timer: 1800 },
  { slug: 'eco-dome-aldani', name: "Eco-Dome Al'dani", short: 'ECO', timer: 1800 },
];

function getDungeonIcon(slug) {
  return `https://cdnassets.raider.io/images/dungeons/expansion10/base/${slug}.jpg`;
}

function calcRunScore(keyLevel, stars) {
  if (keyLevel < 2) return 0;
  const base = keyLevel * 7 + 20;
  return base + (stars === 3 ? 10 : stars === 2 ? 5 : 0);
}

function calcDungeonTotalScore(f, t) {
  const hi = Math.max(f || 0, t || 0), lo = Math.min(f || 0, t || 0);
  return Math.round(hi * 1.5 + lo * 0.5);
}

function formatTime(sec) {
  return `${Math.floor(sec / 60)}:${String(Math.round(sec % 60)).padStart(2, '0')}`;
}

function getAffixesForLevel(kl, weekly) {
  const a = [weekly || 'Fortified'];
  if (kl >= 4) a.push("Xal'atath's Bargain");
  if (kl >= 7) a.push("Challenger's Peril");
  if (kl >= 10) a.push(weekly === 'Fortified' ? 'Tyrannical' : 'Fortified');
  if (kl >= 12) { const i = a.indexOf("Challenger's Peril"); if (i > -1) a.splice(i, 1, "Challenger's Bane"); }
  return a;
}

// Fetch with CORS proxy fallback for Raider.io API
async function fetchWithCorsFallback(url, opts) {
  // For raider.io URLs, skip direct fetch and use proxy immediately
  // (direct fetch returns 200 but browser blocks response due to CORS)
  const needsProxy = url.includes('raider.io');

  if (!needsProxy) {
    try {
      const r = await fetch(url, opts);
      if (r.ok) return r;
    } catch (e) {}
  }

  // Try Cloudflare Worker proxy (deployed for this app)
  try {
    const cfWorker = 'https://syrs-mplus-helper-proxy.diabtraders.workers.dev/?url=' + encodeURIComponent(url);
    const rCF = await fetch(cfWorker, opts);
    if (rCF && rCF.ok) return rCF;
  } catch (e) {}
  // Try local proxy (for development with proxy-server.js)
  try {
    const local = 'http://127.0.0.1:3000/proxy?url=' + encodeURIComponent(url);
    const rLocal = await fetch(local, opts);
    if (rLocal && rLocal.ok) return rLocal;
  } catch (e) {}
  // Fallback to public proxies (may be unreliable)
  try {
    const proxy = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
    const r2 = await fetch(proxy, opts);
    if (r2.ok) return r2;
  } catch (e) {}
  try {
    const proxy2 = 'https://corsproxy.io/?' + encodeURIComponent(url);
    return fetch(proxy2, opts);
  } catch (e) {
    throw e;
  }
}

function getScoreColor(s) {
  if (s >= 2500) return '#ff8000';
  if (s >= 2000) return '#a335ee';
  if (s >= 1500) return '#0070dd';
  if (s >= 1000) return '#1eff00';
  if (s >= 500) return '#ffffff';
  return '#9d9d9d';
}

function buildDungeonState(bestRuns, altRuns, dungeonList) {
  const st = {};
  dungeonList.forEach(d => {
    st[d.slug] = {
      name: d.name, slug: d.slug, short: d.short, timer: d.timer,
      icon: getDungeonIcon(d.slug),
      fortified: { score: 0, keyLevel: 0, stars: 0 },
      tyrannical: { score: 0, keyLevel: 0, stars: 0 },
      totalScore: 0,
    };
  });
  [...(bestRuns||[]), ...(altRuns||[])].forEach(run => {
    const slug = run.dungeon?.slug || '';
    const key = Object.keys(st).find(k => k === slug || st[k].name === run.dungeon?.name || st[k].short === run.short_name);
    if (!key) return;
    const aff = run.affixes?.[0]?.name?.toLowerCase()?.includes('tyrannical') ? 'tyrannical' : 'fortified';
    const rs = run.score || calcRunScore(run.mythic_level, run.num_keystone_upgrades || 1);
    if (rs > st[key][aff].score) {
      st[key][aff] = { score: rs, keyLevel: run.mythic_level, stars: run.num_keystone_upgrades || 1 };
    }
  });
  Object.keys(st).forEach(k => { st[k].totalScore = calcDungeonTotalScore(st[k].fortified.score, st[k].tyrannical.score); });
  return st;
}

function findPaths(ds, target, current, con, keys) {
  const diff = target - current;
  if (diff <= 0) return { quickest: [], easiest: [], balanced: [] };
  const cands = [];
  const dungeons = Object.values(ds).filter(d => !con.allowedDungeons?.length || con.allowedDungeons.includes(d.slug));
  const mk = con.maxKeyLevel || 30;
  dungeons.forEach(d => {
    ['fortified', 'tyrannical'].forEach(aff => {
      const cur = d[aff];
      for (let kl = Math.max(2, cur.keyLevel || 1); kl <= mk; kl++) {
        for (let s = 1; s <= 3; s++) {
          const ns = calcRunScore(kl, s);
          if (ns <= cur.score) continue;
          const nt = calcDungeonTotalScore(aff === 'fortified' ? ns : d.fortified.score, aff === 'tyrannical' ? ns : d.tyrannical.score);
          const gain = nt - d.totalScore;
          if (gain <= 0) continue;
          const tl = d.timer || 2100;
          cands.push({
            dungeon: d.name, slug: d.slug, short: d.short, icon: d.icon,
            affix: aff, keyLevel: kl, stars: s, runScore: ns, scoreGain: gain,
            estTime: Math.round(s === 3 ? tl * 0.55 : s === 2 ? tl * 0.75 : tl * 0.95),
            timerLimit: tl, affixes: getAffixesForLevel(kl, aff === 'fortified' ? 'Fortified' : 'Tyrannical'),
          });
        }
      }
    });
  });
  let fc = cands;
  if (con.useKeystones && keys?.length) fc = cands.filter(c => keys.some(k => k.slug === c.slug && k.level === c.keyLevel));
  return { quickest: greedyPath(fc, diff, 'eff'), easiest: greedyPath(fc, diff, 'easy'), balanced: greedyPath(fc, diff, 'bal') };
}

function greedyPath(cs, diff, strat) {
  if (!cs.length) return [];
  let sorted;
  if (strat === 'eff') sorted = [...cs].sort((a, b) => b.scoreGain - a.scoreGain || a.keyLevel - b.keyLevel);
  else if (strat === 'easy') sorted = [...cs].sort((a, b) => a.keyLevel - b.keyLevel || b.scoreGain - a.scoreGain);
  else sorted = [...cs].sort((a, b) => (b.scoreGain / (b.keyLevel || 1)) - (a.scoreGain / (a.keyLevel || 1)));
  const path = [], used = {};
  let rem = diff;
  for (const c of sorted) {
    if (rem <= 0) break;
    const k = `${c.slug}-${c.affix}`;
    if (used[k]) continue;
    path.push({ ...c }); rem -= c.scoreGain; used[k] = true;
  }
  return path;
}

function saveToCookies(s) { try { document.cookie = `syrmplus_searches=${encodeURIComponent(JSON.stringify(s))}; expires=${new Date(Date.now()+7776e6).toUTCString()}; path=/; SameSite=Lax`; } catch(e){} }
function loadFromCookies() { try { const m = document.cookie.match(/syrmplus_searches=([^;]+)/); return m ? JSON.parse(decodeURIComponent(m[1])) : []; } catch(e){ return []; } }
function clearCookies() { document.cookie = 'syrmplus_searches=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;'; }

function RealmAutocomplete({ value, onChange, region, realmsData }) {
  const [open, setOpen] = useState(false);
  const [idx, setIdx] = useState(-1);
  const ref = useRef(null);
  const realms = realmsData[region] || [];
  const filtered = useMemo(() => {
    if (!value || value.length < 1) return [];
    const q = value.toLowerCase().replace(/['\s-]/g, '');
    return realms.filter(r => {
      const n = r.name.toLowerCase().replace(/['\s-]/g, '');
      const s = (r.slug||'').toLowerCase().replace(/['\s-]/g, '');
      return n.includes(q) || s.includes(q);
    }).slice(0, 12);
  }, [value, realms]);
  useEffect(() => { setIdx(-1); }, [filtered]);
  useEffect(() => {
    const h = (e) => { if (ref.current && !ref.current.contains(e.target)) setOpen(false); };
    document.addEventListener('mousedown', h);
    return () => document.removeEventListener('mousedown', h);
  }, []);
  const select = (r) => { onChange(r.name); setOpen(false); };
  const highlight = (text) => {
    if (!value) return text;
    const q = value.trim().toLowerCase();
    const low = text.toLowerCase();
    const i = low.indexOf(q);
    if (i === -1) return text;
    return [text.slice(0, i), <mark key="m">{text.slice(i, i + q.length)}</mark>, text.slice(i + q.length)];
  };
  return (
    <div className="input-group" ref={ref}>
      <label>Realm</label>
      <input className="input" placeholder="Start typing..." value={value} autoComplete="off"
        onChange={e => { onChange(e.target.value); setOpen(true); }}
        onFocus={() => { if (value.length >= 1) setOpen(true); }}
        onKeyDown={e => {
          if (!open || !filtered.length) return;
          if (e.key === 'ArrowDown') { e.preventDefault(); setIdx(i => Math.min(i+1, filtered.length-1)); }
          else if (e.key === 'ArrowUp') { e.preventDefault(); setIdx(i => Math.max(i-1, 0)); }
          else if (e.key === 'Enter' && idx >= 0) { e.preventDefault(); select(filtered[idx]); }
          else if (e.key === 'Escape') setOpen(false);
        }} />
      {open && filtered.length > 0 && (
        <div className="autocomplete-dropdown">
          {filtered.map((r, i) => (
            <div key={r.slug} className={`autocomplete-item ${i === idx ? 'active' : ''}`}
              onClick={() => select(r)} onMouseEnter={() => setIdx(i)}>
              {highlight(r.name)}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

function ThemeToggle({ theme, onToggle }) {
  return (
    <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
      <span className="theme-toggle-label">‚òÄÔ∏è</span>
      <div className={`theme-toggle ${theme}`} onClick={onToggle} />
      <span className="theme-toggle-label">üåô</span>
    </div>
  );
}

function StarBadge({ stars }) {
  return <span className={`star-badge star-${stars}`}>{'‚òÖ'.repeat(stars)}{'‚òÜ'.repeat(3-stars)}</span>;
}

function DungeonRunRow({ run, index }) {
  return (
    <div className="dungeon-row fade-in" style={{ animationDelay: `${index*0.04}s` }}>
      <img className="dungeon-thumb" src={run.icon} alt={run.dungeon}
        onError={e => { e.target.src = `https://via.placeholder.com/48x48/2c2d33/5b9cf5?text=${encodeURIComponent(run.short||'?')}`; }} />
      <div className="dungeon-info">
        <div className="dungeon-name">{run.dungeon} <span className="key-level-badge">+{run.keyLevel}</span></div>
        <div className="dungeon-meta">
          <StarBadge stars={run.stars} />
          <span className="time-info">~{formatTime(run.estTime)} / {formatTime(run.timerLimit)}</span>
          <span style={{ color: run.affix==='fortified'?'#4ade80':'#c084fc', fontSize:11, fontWeight:600 }}>
            {run.affix==='fortified'?'Fort':'Tyr'}
          </span>
        </div>
        <div className="affix-badges" style={{ marginTop: 4 }}>
          {(run.affixes||[]).map((a,i) => <span key={i} className="affix-badge">{a}</span>)}
        </div>
      </div>
      <div className="dungeon-score-col">
        <div className="dungeon-score score-delta">+{run.scoreGain}</div>
        <div className="dungeon-score-label">score gain</div>
      </div>
    </div>
  );
}

function PathResults({ path, label, desc }) {
  if (!path?.length) return (
    <div className="card" style={{ marginBottom:16, textAlign:'center', padding:32 }}>
      <div style={{ color:'var(--text-muted)', fontSize:14 }}>No path found. Try adjusting filters.</div>
    </div>
  );
  const tg = path.reduce((s,r) => s+r.scoreGain, 0);
  const tt = path.reduce((s,r) => s+r.estTime, 0);
  const ak = (path.reduce((s,r) => s+r.keyLevel, 0)/path.length).toFixed(1);
  return (
    <div className="card fade-in" style={{ marginBottom:16 }}>
      <div style={{ marginBottom:16 }}>
        <div style={{ fontSize:15, fontWeight:600, marginBottom:4 }}>{label}</div>
        <div style={{ fontSize:12, color:'var(--text-muted)' }}>{desc}</div>
      </div>
      <div className="path-summary">
        <div className="path-stat"><div className="path-stat-value">+{tg}</div><div className="path-stat-label">Total Gain</div></div>
        <div className="path-divider" />
        <div className="path-stat"><div className="path-stat-value">{path.length}</div><div className="path-stat-label">Dungeons</div></div>
        <div className="path-divider" />
        <div className="path-stat"><div className="path-stat-value">~{formatTime(tt)}</div><div className="path-stat-label">Est. Time</div></div>
        <div className="path-divider" />
        <div className="path-stat"><div className="path-stat-value">+{ak}</div><div className="path-stat-label">Avg Key</div></div>
      </div>
      {path.map((r,i) => <DungeonRunRow key={i} run={r} index={i} />)}
    </div>
  );
}

function PrivacyModal({ onClose }) {
  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={e => e.stopPropagation()}>
        <h2>üç™ Privacy Policy ‚Äî Cookie Usage</h2>
        <p><strong>What we store:</strong> When you save a search, we store the character name, realm, region, target score, and constraint settings in a browser cookie on your device.</p>
        <p><strong>What we do NOT store:</strong> No personal information, email addresses, IP addresses, or analytics data. No login system, tracking, or third-party sharing.</p>
        <p><strong>How cookies work here:</strong> A single cookie (<code>syrmplus_searches</code>) remembers your past searches so you can quickly re-run them. It is stored entirely on YOUR device.</p>
        <p><strong>No server storage:</strong> All data stays in your browser. The only external requests go to the public Raider.io API.</p>
        <p><strong>Deleting your data:</strong> Use "Clear All" in Saved Searches, or clear cookies in your browser settings.</p>
        <p><strong>Duration:</strong> Cookies expire after 90 days.</p>
        <p style={{ marginTop:16, paddingTop:12, borderTop:'1px solid var(--border)' }}><em>Last updated: {new Date().toLocaleDateString()}</em></p>
        <div style={{ marginTop:20, textAlign:'right' }}><button className="btn btn-primary" onClick={onClose}>Got it</button></div>
      </div>
    </div>
  );
}

function App() {
  const [theme, setTheme] = useState('dark');
  const [charName, setCharName] = useState('');
  const [realm, setRealm] = useState('');
  const [region, setRegion] = useState('us');
  const [targetScore, setTargetScore] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [charData, setCharData] = useState(null);
  const [dungeonState, setDungeonState] = useState(null);
  const [results, setResults] = useState(null);
  const [activeTab, setActiveTab] = useState('quickest');
  const [seasonName, setSeasonName] = useState('');
  const [allowedDungeons, setAllowedDungeons] = useState([]);
  const [maxKeyLevel, setMaxKeyLevel] = useState('');
  const [advancedMode, setAdvancedMode] = useState(false);
  const [keystones, setKeystones] = useState([{ slug:'', level:'' }]);
  const [savedSearches, setSavedSearches] = useState([]);
  const [showPrivacy, setShowPrivacy] = useState(false);
  const [showSaved, setShowSaved] = useState(false);
  const [showConstraints, setShowConstraints] = useState(false);
  const [realmsData, setRealmsData] = useState({ us:[], eu:[], kr:[], tw:[] });
  const [realmsLoading, setRealmsLoading] = useState(true);
  const [dungeonList, setDungeonList] = useState(FALLBACK_DUNGEONS);

  useEffect(() => { document.body.setAttribute('data-theme', theme); }, [theme]);
  useEffect(() => { setSavedSearches(loadFromCookies()); }, []);

  // Fetch realm lists from raider.io on mount
  useEffect(() => {
    async function go() {
      setRealmsLoading(true);
      const nd = { us:[], eu:[], kr:[], tw:[] };
      for (const r of ['us','eu','kr','tw']) {
        try {
          const resp = await fetchWithCorsFallback(`https://raider.io/api/v1/realms?region=${r}`);
          if (resp && resp.ok) {
            const d = await resp.json();
            if (d.realms && d.realms.length) nd[r] = d.realms.map(x => ({ name: x.name, slug: x.slug })).sort((a,b) => a.name.localeCompare(b.name));
          }
        } catch(e) {
          // ignore fetch errors ‚Äî we'll fall back to a small bundled list below
        }
        // If API returned nothing (or fetch blocked from file://), use fallback
        if (!nd[r] || nd[r].length === 0) nd[r] = FALLBACK_REALMS[r] || [];
      }
      setRealmsData(nd);
      setRealmsLoading(false);
    }
    go();
  }, []);

  const toggleTheme = () => setTheme(t => t==='dark'?'light':'dark');
  const toggleDungeon = (slug) => setAllowedDungeons(p => p.includes(slug)?p.filter(s=>s!==slug):[...p,slug]);
  const addKeystone = () => setKeystones(p => [...p, {slug:'',level:''}]);
  const removeKeystone = (i) => setKeystones(p => p.filter((_,x)=>x!==i));
  const updateKeystone = (i,f,v) => setKeystones(p => p.map((k,x)=>x===i?{...k,[f]:v}:k));

  const getRealmSlug = (name) => {
    const rl = realmsData[region]||[];
    const f = rl.find(r => r.name.toLowerCase() === name.trim().toLowerCase());
    return f ? f.slug : name.trim().toLowerCase().replace(/'/g,'').replace(/\s+/g,'-');
  };

  async function lookupCharacter() {
    if (!charName.trim() || !realm.trim()) { setError('Please enter both character name and realm.'); return; }
    setLoading(true); setError(''); setCharData(null); setDungeonState(null); setResults(null);
    try {
      const slug = getRealmSlug(realm);
      const url = `https://raider.io/api/v1/characters/profile?region=${region}&realm=${encodeURIComponent(slug)}&name=${encodeURIComponent(charName.trim())}&fields=mythic_plus_scores_by_season:current,mythic_plus_best_runs:all,mythic_plus_alternate_runs:all,gear`;
      const resp = await fetchWithCorsFallback(url);
      if (!resp.ok) {
        if (resp.status===400||resp.status===404) throw new Error('Character not found. Check the name, realm, and region.');
        throw new Error(`Raider.io API error (${resp.status})`);
      }
      const data = await resp.json();
      setCharData(data);
      if (data.mythic_plus_scores_by_season?.[0]?.season) setSeasonName(data.mythic_plus_scores_by_season[0].season);
      const best = data.mythic_plus_best_runs||[], alt = data.mythic_plus_alternate_runs||[];
      let dl = FALLBACK_DUNGEONS;
      if (best.length||alt.length) {
        const seen = new Set(), apiD = [];
        [...best,...alt].forEach(r => {
          const s = r.dungeon?.slug;
          if (s && !seen.has(s)) {
            seen.add(s);
            apiD.push({ slug:s, name:r.dungeon?.name||s, short:r.short_name||s.substring(0,4).toUpperCase(), timer:Math.round((r.par_time_ms||2100000)/1000) });
          }
        });
        if (apiD.length) { dl = apiD; setDungeonList(apiD); }
      }
      setDungeonState(buildDungeonState(best, alt, dl));
    } catch(e) {
      if (e.message?.includes('NetworkError')||e.message?.includes('Failed to fetch')||(e.name==='TypeError'&&e.message?.includes('fetch')))
        setError('Network request blocked ‚Äî please download the HTML file and open it directly in your browser.');
      else setError(e.message||'Failed to look up character.');
    } finally { setLoading(false); }
  }

  function calculatePaths() {
    if (!dungeonState) return;
    const t = parseInt(targetScore)||0, c = charData?.mythic_plus_scores_by_season?.[0]?.scores?.all||0;
    if (t<=c) { setError('Target score must be higher than current score.'); return; }
    setError('');
    const con = { allowedDungeons:allowedDungeons.length?allowedDungeons:null, maxKeyLevel:maxKeyLevel?parseInt(maxKeyLevel):null, useKeystones:advancedMode };
    const ks = advancedMode ? keystones.filter(k=>k.slug&&k.level).map(k=>({slug:k.slug,level:parseInt(k.level)})) : null;
    setResults(findPaths(dungeonState, t, c, con, ks));
    setActiveTab('quickest');
  }

  function saveSearch() {
    const s = { id:Date.now(), charName:charName.trim(), realm:realm.trim(), region, targetScore, allowedDungeons:[...allowedDungeons], maxKeyLevel, advancedMode, keystones:advancedMode?[...keystones]:[], savedAt:new Date().toISOString() };
    const u = [s,...savedSearches].slice(0,10); setSavedSearches(u); saveToCookies(u);
  }
  function loadSearch(s) {
    setCharName(s.charName); setRealm(s.realm); setRegion(s.region);
    setTargetScore(s.targetScore||''); setAllowedDungeons(s.allowedDungeons||[]);
    setMaxKeyLevel(s.maxKeyLevel||''); setAdvancedMode(s.advancedMode||false);
    setKeystones(s.keystones?.length?s.keystones:[{slug:'',level:''}]); setShowSaved(false);
  }
  function deleteSaved(id) { const u=savedSearches.filter(s=>s.id!==id); setSavedSearches(u); saveToCookies(u); }
  function clearAllSaved() { setSavedSearches([]); clearCookies(); }

  const cs = charData?.mythic_plus_scores_by_season?.[0]?.scores?.all||0;
  const av = charData?.thumbnail_url;

  const formatSeasonName = (s) => {
    if (!s) return '';
    return s.replace(/-/g,' ').replace('season tww ','TWW Season ').replace('season df ','DF Season ').replace('season ','Season ').replace(/\b\w/g,c=>c.toUpperCase());
  };

  return (
    <div>
      <header className="header">
        <div className="container header-inner">
          <div className="logo">
            <div className="logo-icon">S</div>
            <h1><span>Syr's</span> M+ Score Goal Helper</h1>
          </div>
          <div className="header-actions">
            <button className="btn btn-ghost btn-sm" onClick={()=>setShowSaved(!showSaved)}>üìã Saved ({savedSearches.length})</button>
            <ThemeToggle theme={theme} onToggle={toggleTheme} />
          </div>
        </div>
      </header>
      <main className="container">
        <div className="section">
          <div className="card">
            <div style={{ display:'flex', alignItems:'center', justifyContent:'space-between', marginBottom:16 }}>
              <div className="section-title" style={{ margin:0 }}><div className="dot" /> Character Lookup</div>
              {seasonName && <div className="season-badge">üè∞ {formatSeasonName(seasonName)}</div>}
            </div>
            <div className="search-grid">
              <div className="input-group">
                <label>Character Name</label>
                <input className="input" placeholder="e.g. Syrsjr" value={charName}
                  onChange={e=>setCharName(e.target.value)} onKeyDown={e=>e.key==='Enter'&&lookupCharacter()} />
              </div>
              <RealmAutocomplete value={realm} onChange={setRealm} region={region} realmsData={realmsData} />
              <div className="input-group">
                <label>Region</label>
                <select value={region} onChange={e=>setRegion(e.target.value)}>
                  {REGIONS.map(r=><option key={r.value} value={r.value}>{r.label}</option>)}
                </select>
              </div>
              <button className="btn btn-primary" onClick={lookupCharacter} disabled={loading} style={{alignSelf:'end'}}>
                {loading?'...':'Look Up'}
              </button>
            </div>
            {realmsLoading && <div className="info-msg" style={{marginTop:12}}>Loading realm lists from Raider.io...</div>}
            {charData && (
              <div className="target-row">
                <div className="input-group">
                  <label>Target M+ Score</label>
                  <input className="input mono" type="number" placeholder="e.g. 2500" value={targetScore} onChange={e=>setTargetScore(e.target.value)} />
                </div>
                <div style={{ display:'flex', gap:8, alignItems:'flex-end', flexWrap:'wrap' }}>
                  <button className="btn btn-primary" onClick={calculatePaths} disabled={!targetScore}>Calculate Paths</button>
                  <button className="btn btn-secondary" onClick={saveSearch}>üíæ Save</button>
                  <button className="btn btn-ghost btn-sm" onClick={()=>setShowConstraints(!showConstraints)}>
                    ‚öôÔ∏è {showConstraints?'Hide':'Filters'}
                  </button>
                </div>
              </div>
            )}
            {showConstraints && charData && (
              <div style={{ marginTop:20, paddingTop:16, borderTop:'1px solid var(--border)' }}>
                <div className="constraints-grid">
                  <div>
                    <div style={{ fontSize:13, fontWeight:500, color:'var(--text-secondary)', marginBottom:8 }}>
                      Limit to Dungeons <span style={{ fontSize:11, color:'var(--text-muted)' }}>(leave unchecked for all)</span>
                    </div>
                    <div className="dungeon-checkboxes">
                      {dungeonList.map(d=>(
                        <label key={d.slug} className="checkbox-label">
                          <input type="checkbox" checked={allowedDungeons.includes(d.slug)} onChange={()=>toggleDungeon(d.slug)} />
                          {d.short||d.name}
                        </label>
                      ))}
                    </div>
                  </div>
                  <div>
                    <div className="input-group">
                      <label>Max Key Level</label>
                      <input className="input mono" type="number" placeholder="No limit" value={maxKeyLevel} onChange={e=>setMaxKeyLevel(e.target.value)} min="2" max="40" />
                    </div>
                    <div className="toggle-row">
                      <input type="checkbox" checked={advancedMode} onChange={e=>setAdvancedMode(e.target.checked)} style={{accentColor:'var(--accent)'}} />
                      <span className="toggle-label">Advanced: Use Group Keystones</span>
                    </div>
                    {advancedMode && (
                      <div style={{marginTop:12}}>
                        <div style={{fontSize:12,color:'var(--text-muted)',marginBottom:8}}>Enter your group's available keystones:</div>
                        {keystones.map((k,i)=>(
                          <div key={i} className="keystone-grid">
                            <select value={k.slug} onChange={e=>updateKeystone(i,'slug',e.target.value)}>
                              <option value="">Select dungeon...</option>
                              {dungeonList.map(d=><option key={d.slug} value={d.slug}>{d.short||d.name}</option>)}
                            </select>
                            <input className="input mono" type="number" placeholder="+Lvl" value={k.level} onChange={e=>updateKeystone(i,'level',e.target.value)} min="2" max="40" />
                            <button className="btn btn-ghost btn-sm" onClick={()=>removeKeystone(i)}>‚úï</button>
                          </div>
                        ))}
                        <button className="btn btn-secondary btn-sm" onClick={addKeystone} style={{marginTop:4}}>+ Add Key</button>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
        {error && <div className="error-msg" style={{marginBottom:24}}>{error}</div>}
        {loading && <div className="loading-spinner" />}
        {charData && !loading && (
          <div className="section fade-in">
            <div className="card current-score-card">
              {av && <img className="avatar" src={av} alt="avatar" onError={e=>{e.target.style.display='none';}} />}
              <div className="char-details">
                <div className="char-name">{charData.name}</div>
                <div className="char-realm">{charData.realm} ‚Äî {charData.region?.toUpperCase()}</div>
                <div className="char-class">
                  {charData.active_spec_name} {charData.class}
                  {charData.gear?.item_level_equipped?` ‚Ä¢ ${charData.gear.item_level_equipped} ilvl`:''}
                </div>
              </div>
              <div className="current-score-display">
                <div className="current-score-num" style={{color:getScoreColor(cs)}}>{cs.toFixed(1)}</div>
                <div className="current-score-label">Current M+ Score</div>
              </div>
            </div>
            {dungeonState && (
              <div style={{marginTop:8}}>
                <div className="section-title"><div className="dot" /> Current Dungeon Scores</div>
                {Object.values(dungeonState).map((d,i)=>(
                  <div key={d.slug} className="dungeon-row fade-in" style={{animationDelay:`${i*0.03}s`}}>
                    <img className="dungeon-thumb" src={d.icon} alt={d.name}
                      onError={e=>{e.target.src=`https://via.placeholder.com/48x48/2c2d33/5b9cf5?text=${encodeURIComponent(d.short)}`;}} />
                    <div className="dungeon-info">
                      <div className="dungeon-name">{d.name}</div>
                      <div className="dungeon-meta">
                        {d.fortified.keyLevel>0&&<span><span style={{color:'#4ade80',fontWeight:600,fontSize:11}}>Fort</span> +{d.fortified.keyLevel} <StarBadge stars={d.fortified.stars||1} /></span>}
                        {d.tyrannical.keyLevel>0&&<span><span style={{color:'#c084fc',fontWeight:600,fontSize:11}}>Tyr</span> +{d.tyrannical.keyLevel} <StarBadge stars={d.tyrannical.stars||1} /></span>}
                        {d.fortified.keyLevel===0&&d.tyrannical.keyLevel===0&&<span style={{color:'var(--text-muted)',fontSize:12}}>Not completed</span>}
                      </div>
                    </div>
                    <div className="dungeon-score-col">
                      <div className="dungeon-score" style={{color:getScoreColor(d.totalScore*8)}}>{d.totalScore}</div>
                      <div className="dungeon-score-label">dungeon score</div>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}
        {results && (
          <div className="section fade-in">
            <div className="section-title"><div className="dot" /> Paths to {targetScore} Score</div>
            <div style={{marginBottom:4,fontSize:13,color:'var(--text-muted)'}}>
              Need <strong style={{color:'var(--success)'}}>+{(parseInt(targetScore)-cs).toFixed(0)}</strong> more score
            </div>
            <div className="tabs">
              <button className={`tab ${activeTab==='quickest'?'active':''}`} onClick={()=>setActiveTab('quickest')}>‚ö° Quickest</button>
              <button className={`tab ${activeTab==='balanced'?'active':''}`} onClick={()=>setActiveTab('balanced')}>‚öñÔ∏è Balanced</button>
              <button className={`tab ${activeTab==='easiest'?'active':''}`} onClick={()=>setActiveTab('easiest')}>üåø Easiest</button>
            </div>
            {activeTab==='quickest'&&<PathResults path={results.quickest} label="‚ö° Quickest Path" desc="Fewest runs ‚Äî max score gain per dungeon" />}
            {activeTab==='balanced'&&<PathResults path={results.balanced} label="‚öñÔ∏è Balanced Path" desc="Best score gain to key difficulty ratio" />}
            {activeTab==='easiest'&&<PathResults path={results.easiest} label="üåø Easiest Path" desc="Lowest keys possible ‚Äî may need more runs" />}
          </div>
        )}
        {showSaved && (
          <div className="section fade-in">
            <div className="card">
              <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',marginBottom:16}}>
                <div className="section-title" style={{margin:0}}><div className="dot" /> Saved Searches</div>
                {savedSearches.length>0&&<button className="btn btn-danger btn-sm" onClick={clearAllSaved}>Clear All</button>}
              </div>
              {savedSearches.length===0 ? (
                <div style={{textAlign:'center',padding:24,color:'var(--text-muted)',fontSize:14}}>No saved searches yet.</div>
              ) : (
                <div className="saved-list">
                  {savedSearches.map(s=>(
                    <div key={s.id} className="saved-item" onClick={()=>loadSearch(s)}>
                      <div>
                        <div className="saved-item-name">{s.charName} ‚Äî {s.realm} ({s.region.toUpperCase()})</div>
                        <div className="saved-item-meta">Target: {s.targetScore||'‚Äî'} ‚Ä¢ {new Date(s.savedAt).toLocaleDateString()}</div>
                      </div>
                      <button className="btn btn-ghost btn-sm" onClick={e=>{e.stopPropagation();deleteSaved(s.id);}}>‚úï</button>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        )}
      </main>
      <footer className="footer">
        <p>Syr's M+ Score Goal Helper ‚Äî Data from <a href="https://raider.io" target="_blank" rel="noopener noreferrer">Raider.io</a> ‚Ä¢ <a onClick={()=>setShowPrivacy(true)}>Privacy Policy</a></p>
        <p style={{marginTop:4}}>Score calculations are approximate. Dungeon list and season update automatically from the API.</p>
      </footer>
      {showPrivacy && <PrivacyModal onClose={()=>setShowPrivacy(false)} />}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('app')).render(<App />);
</script>
</body>
</html>
