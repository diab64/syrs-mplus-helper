<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Syr's M+ Score Goal Helper</title>
<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Chivo+Mono:wght@400;500;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg-primary: #1a1b1e;
  --bg-secondary: #25262b;
  --bg-tertiary: #2c2d33;
  --bg-card: #2c2d33;
  --bg-input: #32333a;
  --bg-hover: #373840;
  --text-primary: #e4e5e7;
  --text-secondary: #a1a2a6;
  --text-muted: #6d6e73;
  --border: #3a3b42;
  --accent: #5b9cf5;
  --accent-hover: #4a8be4;
  --accent-dim: rgba(91,156,245,0.15);
  --success: #4ade80;
  --warning: #fbbf24;
  --danger: #f87171;
  --star1: #94a3b8;
  --star2: #fbbf24;
  --star3: #f97316;
  --shadow: 0 4px 24px rgba(0,0,0,0.3);
  --radius: 10px;
  --radius-sm: 6px;
  --transition: 0.2s ease;
}
[data-theme="light"] {
  --bg-primary: #f0f1f3;
  --bg-secondary: #ffffff;
  --bg-tertiary: #f7f8fa;
  --bg-card: #ffffff;
  --bg-input: #edeef0;
  --bg-hover: #e5e6e8;
  --text-primary: #1a1b1e;
  --text-secondary: #5c5d63;
  --text-muted: #9a9ba0;
  --border: #d8d9dd;
  --accent: #3b7de0;
  --accent-hover: #2a6ccf;
  --accent-dim: rgba(59,125,224,0.1);
  --shadow: 0 4px 24px rgba(0,0,0,0.08);
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Outfit', sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  min-height: 100vh;
  transition: background var(--transition), color var(--transition);
}
.mono { font-family: 'Chivo Mono', monospace; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--bg-primary); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
.container { max-width: 1400px; margin: 0 auto; padding: 0 20px; }
.header { padding: 10px 0; border-bottom: 1px solid var(--border); margin-bottom: 12px; max-height: 60px; }
/* Hide number input spinners */
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
input[type="number"] { -moz-appearance: textfield; }
.header-inner { display: flex; align-items: center; justify-content: space-between; }
.logo { display: flex; align-items: center; gap: 12px; }
.logo-icon {
  width: 36px; height: 36px; border-radius: 8px;
  background: linear-gradient(135deg, var(--accent), #8b5cf6);
  display: flex; align-items: center; justify-content: center;
  font-weight: 700; font-size: 16px; color: #fff;
}
.logo h1 { font-size: 20px; font-weight: 600; letter-spacing: -0.3px; }
.logo span { color: var(--accent); }
.header-actions { display: flex; align-items: center; gap: 12px; }
.theme-toggle {
  width: 52px; height: 28px; border-radius: 14px;
  background: var(--bg-input); border: 1px solid var(--border);
  cursor: pointer; position: relative; transition: all var(--transition);
}
.theme-toggle::after {
  content: ''; position: absolute; width: 22px; height: 22px;
  border-radius: 50%; background: var(--accent);
  top: 2px; left: 2px; transition: transform var(--transition);
}
.theme-toggle.light::after { transform: translateX(24px); }
.theme-toggle-label { font-size: 12px; color: var(--text-muted); }
.btn {
  padding: 10px 20px; border-radius: var(--radius-sm);
  font-family: 'Outfit', sans-serif; font-weight: 500; font-size: 14px;
  border: none; cursor: pointer; transition: all var(--transition);
  display: inline-flex; align-items: center; gap: 8px;
}
.btn-primary { background: var(--accent); color: #fff; }
.btn-primary:hover { background: var(--accent-hover); transform: translateY(-1px); }
.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
.btn-secondary { background: var(--bg-input); color: var(--text-primary); border: 1px solid var(--border); }
.btn-secondary:hover { background: var(--bg-hover); }
.btn-lookup { background: #5a8fd4; color: #fff; }
.btn-lookup:hover { background: #4a7ebd; }
.btn-sm { padding: 6px 14px; font-size: 16px; }
.btn-ghost { background: transparent; color: var(--text-secondary); padding: 6px 10px; }
.btn-ghost:hover { color: var(--text-primary); background: var(--bg-hover); }
.btn-danger { background: transparent; color: var(--danger); }
.btn-danger:hover { background: rgba(248,113,113,0.1); }
.input-group { display: flex; flex-direction: column; gap: 6px; position: relative; }
.input-group label { font-size: 14px; font-weight: 500; color: var(--text-secondary); }
.input, select {
  padding: 10px 14px; border-radius: var(--radius-sm);
  background: var(--bg-input); border: 1px solid var(--border);
  color: var(--text-primary); font-family: 'Outfit', sans-serif;
  font-size: 14px; transition: all var(--transition); outline: none; width: 100%;
}
.input:focus, select:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-dim); }
select {
  cursor: pointer; appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%236d6e73' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat; background-position: right 12px center; padding-right: 32px;
}
.autocomplete-dropdown {
  position: absolute; top: 100%; left: 0; right: 0; z-index: 100;
  background: var(--bg-card); border: 1px solid var(--border);
  border-radius: var(--radius-sm); margin-top: 4px;
  max-height: 200px; overflow-y: auto; box-shadow: var(--shadow);
}
.autocomplete-item {
  padding: 8px 14px; cursor: pointer; font-size: 14px;
  color: var(--text-primary); transition: background 0.1s;
}
.autocomplete-item:hover, .autocomplete-item.active { background: var(--accent-dim); color: var(--accent); }
.autocomplete-item .realm-slug { font-size: 11px; color: var(--text-muted); margin-left: 6px; }
.autocomplete-item mark { background: transparent; color: var(--accent); font-weight: 600; }
.card {
  background: var(--bg-card); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 24px; transition: all var(--transition);
}
.search-grid { display: grid; grid-template-columns: 1fr; gap: 12px; align-items: end; }
.search-grid.full-width { grid-template-columns: 1fr; }
.search-grid.two-col { grid-template-columns: 1fr 1fr 140px 120px; }
.target-row { display: grid; grid-template-columns: 200px 1fr; gap: 12px; align-items: end; margin-top: 16px; }
.tabs { display: flex; gap: 4px; margin-bottom: 24px; }
.tab {
  padding: 10px 20px; border-radius: var(--radius-sm);
  background: var(--bg-input); color: var(--text-secondary);
  font-family: 'Outfit', sans-serif; font-weight: 500;
  font-size: 14px; border: 1px solid var(--border); cursor: pointer; transition: all var(--transition);
}
.tab:hover { color: var(--text-primary); background: var(--bg-hover); }
.tab.active { background: var(--accent); color: #fff; }
.dungeon-row {
  display: flex; align-items: center; gap: 16px;
  padding: 14px 16px; border-radius: var(--radius-sm);
  background: var(--bg-tertiary); border: 1px solid var(--border);
  margin-bottom: 8px; transition: all var(--transition);
}
.dungeon-row:hover { border-color: var(--accent); }
.dungeon-thumb {
  width: 48px; height: 48px; border-radius: 8px;
  object-fit: cover; flex-shrink: 0; border: 2px solid var(--border); background: var(--bg-input);
}
.dungeon-info { flex: 1; min-width: 0; }
.dungeon-name { font-weight: 600; font-size: 15px; margin-bottom: 2px; }
.dungeon-meta { font-size: 12px; color: var(--text-muted); display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
.dungeon-score-col { text-align: right; min-width: 80px; }
.dungeon-score { font-size: 20px; font-weight: 700; font-family: 'Chivo Mono', monospace; }
[data-theme="light"] .dungeon-score { text-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 1px 3px rgba(0,0,0,0.25); }
.dungeon-score-label { font-size: 11px; color: var(--text-secondary); }
.star-badge {
  display: inline-flex; align-items: center; gap: 3px;
  padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600;
}
.star-1 { background: rgba(148,163,184,0.15); color: var(--star1); }
.star-2 { background: rgba(251,191,36,0.15); color: var(--star2); }
.star-3 { background: rgba(249,115,22,0.15); color: var(--star3); }
.key-level-badge {
  display: inline-flex; padding: 2px 8px; border-radius: 10px;
  font-size: 12px; font-weight: 600; background: var(--accent-dim); color: var(--accent);
  font-family: 'Chivo Mono', monospace;
}
.affix-badges { display: flex; gap: 4px; flex-wrap: wrap; }
.affix-badge {
  padding: 1px 6px; border-radius: 4px; font-size: 10px;
  background: var(--bg-hover); color: var(--text-secondary); border: 1px solid var(--border);
}
.time-info { font-size: 12px; color: var(--text-secondary); font-family: 'Chivo Mono', monospace; }
.constraints-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 16px; }
.dungeon-checkboxes { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 8px; }
.checkbox-label {
  display: flex; align-items: center; gap: 8px;
  font-size: 13px; cursor: pointer; color: var(--text-secondary);
  padding: 4px 8px; border-radius: var(--radius-sm); transition: all var(--transition);
}
.checkbox-label:hover { background: var(--bg-hover); color: var(--text-primary); }
.checkbox-label input { accent-color: var(--accent); }
.keystone-grid { display: grid; grid-template-columns: 1fr 80px 60px; gap: 8px; align-items: center; margin-bottom: 6px; }
.path-summary {
  display: flex; gap: 16px; align-items: center;
  padding: 16px; background: var(--accent-dim);
  border-radius: var(--radius-sm); margin-bottom: 16px;
  border: 1px solid rgba(91,156,245,0.2);
}
.path-stat { text-align: center; }
.path-stat-value { font-size: 24px; font-weight: 700; color: var(--accent); font-family: 'Chivo Mono', monospace; }
.path-stat-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
.path-divider { width: 1px; height: 40px; background: var(--border); }
.score-delta { color: var(--success); }
.saved-list { display: flex; flex-direction: column; gap: 8px; }
.saved-item {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 14px; border-radius: var(--radius-sm);
  background: var(--bg-tertiary); border: 1px solid var(--border);
  cursor: pointer; transition: all var(--transition);
}
.saved-item:hover { border-color: var(--accent); }
.saved-item-name { font-weight: 500; font-size: 14px; }
.saved-item-meta { font-size: 12px; color: var(--text-muted); }
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.6);
  display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 20px;
}
.modal {
  background: var(--bg-card); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 32px;
  max-width: 560px; width: 100%; max-height: 80vh; overflow-y: auto;
}
.modal h2 { font-size: 20px; margin-bottom: 16px; }
.modal p { font-size: 14px; color: var(--text-secondary); line-height: 1.7; margin-bottom: 12px; }
.loading-spinner {
  width: 32px; height: 32px; border: 3px solid var(--border);
  border-top-color: var(--accent); border-radius: 50%;
  animation: spin 0.8s linear infinite; margin: 40px auto;
}
@keyframes spin { to { transform: rotate(360deg); } }
.error-msg {
  padding: 12px 16px; border-radius: var(--radius-sm);
  background: rgba(248,113,113,0.1); border: 1px solid rgba(248,113,113,0.2);
  color: var(--danger); font-size: 14px;
}
.info-msg {
  padding: 12px 16px; border-radius: var(--radius-sm);
  background: var(--accent-dim); border: 1px solid rgba(91,156,245,0.2);
  color: var(--accent); font-size: 13px;
}
.current-score-card { display: flex; align-items: center; gap: 20px; padding: 20px; margin-bottom: 24px; }
.avatar { width: 64px; height: 64px; border-radius: 12px; border: 2px solid var(--accent); object-fit: cover; }
.char-details { flex: 1; }
.char-name { font-size: 22px; font-weight: 700; }
.char-realm { font-size: 13px; color: var(--text-muted); }
.char-class { font-size: 13px; color: var(--text-secondary); margin-top: 2px; }
.current-score-display { text-align: right; }
.current-score-num {
  font-size: 36px; font-weight: 700; font-family: 'Chivo Mono', monospace;
  background: linear-gradient(135deg, var(--accent), #8b5cf6);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.current-score-label { font-size: 12px; color: var(--text-muted); }
.section { margin-bottom: 32px; }
.section-title {
  font-size: 16px; font-weight: 600; margin-bottom: 16px;
  display: flex; align-items: center; gap: 8px;
}
.section-title .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent); }
.toggle-row { display: flex; align-items: center; gap: 12px; margin-top: 16px; margin-bottom: 8px; }
.toggle-label { font-size: 14px; font-weight: 500; }
.season-badge {
  display: inline-flex; align-items: center; gap: 6px;
  padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 500;
  background: var(--accent-dim); color: var(--accent); border: 1px solid rgba(91,156,245,0.2);
}
.footer {
  max-width: 1400px; margin: 48px auto 0; padding: 24px 20px;
  border-top: 1px solid var(--border);
  text-align: center; font-size: 12px; color: var(--text-muted);
}
.footer a { color: var(--accent); text-decoration: none; cursor: pointer; }
.footer a:hover { text-decoration: underline; }
/* Compact dungeon rows for left panel */
.compact-dungeon-row {
  display: flex; align-items: center; gap: 10px;
  padding: 4px 10px; border-radius: var(--radius-sm);
  background: var(--bg-tertiary); border: 1px solid var(--border);
  margin-bottom: 2px; transition: all var(--transition);
}
.compact-dungeon-thumb {
  width: 36px; height: 36px; border-radius: 6px;
  object-fit: cover; flex-shrink: 0; border: 1px solid var(--border); background: var(--bg-input);
}
.compact-dungeon-info {
  flex: 1; min-width: 0; display: flex; flex-direction: row; align-items: center; gap: 6px;
}
.compact-dungeon-name {
  font-weight: 600; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.compact-dungeon-meta { display: flex; align-items: center; gap: 4px; }
.compact-key-level {
  font-size: 14px; font-weight: 700; font-family: 'Chivo Mono', monospace; color: var(--accent);
  flex-shrink: 0;
}
.compact-stars { color: #fbbf24; font-size: 14px; letter-spacing: 0px; flex-shrink: 0; }
.compact-score {
  font-size: 15px; font-weight: 700; font-family: 'Chivo Mono', monospace;
  text-align: right; min-width: 50px; flex-shrink: 0;
}
[data-theme="light"] .compact-score { text-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 1px 3px rgba(0,0,0,0.25); }

/* Two-column app layout (40/60 split) */
.app-two-col {
  display: grid; grid-template-columns: 40% 1fr; gap: 24px; align-items: start;
}
.left-panel { position: sticky; top: 20px; }
.right-panel { min-width: 0; }

/* Condensed form inputs in left panel */
.condensed-form .input-group label { font-size: 14px; font-weight: 600; }
.condensed-form .input, .condensed-form select { padding: 8px 12px; font-size: 14px; }

/* Condensed character card */
.condensed-char {
  display: flex; align-items: center; gap: 10px;
  padding: 10px; margin-bottom: 10px;
  background: var(--bg-tertiary); border: 1px solid var(--border);
  border-radius: var(--radius-sm);
}
.condensed-char-name { font-size: 14px; font-weight: 600; }
.condensed-char-sub { font-size: 11px; color: var(--text-muted); }
.condensed-char-score {
  margin-left: auto; font-size: 22px; font-weight: 700;
  font-family: 'Chivo Mono', monospace; flex-shrink: 0;
}

/* Expandable filter sections */
.expandable-header {
  display: flex; align-items: center; gap: 6px;
  cursor: pointer; font-size: 14px; font-weight: 500;
  color: var(--text-secondary); padding: 4px 0; user-select: none;
}
.expandable-header:hover { color: var(--text-primary); }
.expandable-icon {
  font-size: 14px; font-weight: 700; width: 16px; text-align: center; color: var(--accent);
}

/* Path result rows (right panel) */
.path-row {
  display: flex; align-items: center; justify-content: space-between;
  margin-bottom: 8px; border-radius: var(--radius-sm);
  padding: 14px 16px; background: var(--bg-secondary);
  border: 1px solid var(--border); overflow: hidden;
}
.path-current {
  display: flex; align-items: center; gap: 12px;
  flex: 1; min-width: 0; padding: 0;
}
.path-current-info { flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 2px; }
.path-dungeon-name {
  font-weight: 600; font-size: 16px; color: var(--text-primary);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.path-current-meta { display: flex; align-items: center; gap: 8px; }
.path-key {
  font-size: 17px; font-weight: 700;
  font-family: 'Chivo Mono', monospace; color: var(--accent);
}
.path-stars { color: #fbbf24; font-size: 17px; }
.path-score {
  font-size: 16px; font-weight: 700; font-family: 'Chivo Mono', monospace;
}
[data-theme="light"] .path-score { text-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 1px 3px rgba(0,0,0,0.25); }
.path-thumb {
  width: 40px; height: 40px; border-radius: 6px;
  object-fit: cover; flex-shrink: 0; border: 1px solid var(--border); background: var(--bg-input);
}
.path-arrow-col {
  display: none;
}
.path-arrow-symbol { display: none; }
.path-suggest {
  display: flex; align-items: center; gap: 20px;
  padding: 0; background: transparent; min-width: auto;
}
.path-suggest-run { display: flex; align-items: center; gap: 6px; color: var(--text-primary); }
.path-suggest-time {
  font-size: 12px; color: var(--text-secondary); font-family: 'Chivo Mono', monospace;
}
.path-suggest-gain {
  font-size: 18px; font-weight: 700; font-family: 'Chivo Mono', monospace;
  color: #4ade80;
}
[data-theme="light"] .path-suggest-gain { text-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 1px 3px rgba(0,0,0,0.25); }
[data-theme="light"] .score-delta { text-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 1px 3px rgba(0,0,0,0.25); }
[data-theme="light"] .overall-score-num { text-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 1px 3px rgba(0,0,0,0.25); }

/* Smooth expand/collapse for filter sections */
.expandable-content {
  overflow: hidden;
  transition: max-height 0.28s ease, opacity 0.22s ease;
  max-height: 0;
  opacity: 0;
}
.expandable-content.open {
  max-height: 500px;
  opacity: 1;
}

@media (max-width: 900px) {
  .app-two-col { grid-template-columns: 1fr; }
  .left-panel { position: static; }
}
@media (max-width: 768px) {
  .search-grid { grid-template-columns: 1fr 1fr; }
  .target-row { grid-template-columns: 1fr; }
  .constraints-grid { grid-template-columns: 1fr; }
  .dungeon-checkboxes { grid-template-columns: 1fr; }
  .header-inner { flex-wrap: wrap; gap: 12px; }
  .path-row { flex-direction: column; }
  .path-suggest { min-width: auto; }
  .path-arrow-col {
    padding: 4px 0; border-left: none; border-right: none;
    border-top: 1px solid var(--border); border-bottom: 1px solid var(--border);
  }
}
@keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
.fade-in { animation: fadeIn 0.3s ease forwards; }
</style>
</head>
<body data-theme="dark">
<div id="app"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<script type="text/babel">
const { useState, useEffect, useCallback, useRef, useMemo } = React;

const REGIONS = [
  { value: 'us', label: 'US' },
  { value: 'eu', label: 'EU' },
  { value: 'kr', label: 'KR' },
  { value: 'tw', label: 'TW' },
];

// Blizzard API region hosts
const BLIZZARD_API_HOSTS = {
  us: 'us.api.blizzard.com',
  eu: 'eu.api.blizzard.com',
  kr: 'kr.api.blizzard.com',
  tw: 'tw.api.blizzard.com',
};

// Map Blizzard internal season IDs to marketing names
const SEASON_NAMES = {
  13: 'TWW Season 1', 14: 'TWW Season 2', 15: 'TWW Season 3',
  16: 'TWW Season 4', 17: 'TWW Season 5',
};
function getSeasonDisplayName(id) {
  return SEASON_NAMES[id] || `Season ${id}`;
}

// Small offline fallback for realms so autocomplete works without API
const FALLBACK_REALMS = {
  us: [
    { name: 'Stormrage', slug: 'stormrage' },
    { name: 'Sargeras', slug: 'sargeras' },
    { name: 'Proudmoore', slug: 'proudmoore' },
    { name: 'Tichondrius', slug: 'tichondrius' },
    { name: 'Area 52', slug: 'area-52' },
    { name: 'Illidan', slug: 'illidan' },
    { name: 'Mal\'Ganis', slug: 'malganis' },
    { name: 'Thrall', slug: 'thrall' },
  ],
  eu: [
    { name: 'Silvermoon', slug: 'silvermoon' },
    { name: 'Ragnaros', slug: 'ragnaros' },
    { name: 'Draenor', slug: 'draenor' },
    { name: 'Kazzak', slug: 'kazzak' },
    { name: 'Twisting Nether', slug: 'twisting-nether' },
  ],
  kr: [ { name: 'Azshara', slug: 'azshara' }, { name: 'Hellscream', slug: 'hellscream' } ],
  tw: [ { name: 'Bleeding Hollow', slug: 'bleeding-hollow' }, { name: 'Sundown Marsh', slug: 'sundown-marsh' } ],
};

// TWW Season 3 dungeon pool (fallback if API returns no runs)
const FALLBACK_DUNGEONS = [
  { slug: 'eco-dome-aldani', name: "Eco-Dome Al'dani", short: 'ECO', timer: 1860 },
  { slug: 'ara-kara-city-of-echoes', name: 'Ara-Kara, City of Echoes', short: 'ARA', timer: 1800 },
  { slug: 'the-dawnbreaker', name: 'The Dawnbreaker', short: 'DAWN', timer: 1860 },
  { slug: 'priory-of-the-sacred-flame', name: 'Priory of the Sacred Flame', short: 'PSF', timer: 1950 },
  { slug: 'operation-floodgate', name: 'Operation: Floodgate', short: 'FLOOD', timer: 1980 },
  { slug: 'halls-of-atonement', name: 'Halls of Atonement', short: 'HOA', timer: 1860 },
  { slug: 'tazavesh-streets-of-wonder', name: 'Tazavesh: Streets of Wonder', short: 'STREETS', timer: 2340 },
  { slug: 'tazavesh-soleahs-gambit', name: "Tazavesh: So'leah's Gambit", short: 'GAMBIT', timer: 1800 },
];

// Map API-generated slugs to WoW armory image slugs (only entries that differ)
const DUNGEON_IMAGE_SLUGS = {
  'eco-dome-al-dani': 'eco-dome-aldani',
  'tazavesh-so-leah-s-gambit': 'tazavesh-the-veiled-market',
  'tazavesh-soleahs-gambit': 'tazavesh-the-veiled-market',
  'tazavesh-streets-of-wonder': 'tazavesh-the-veiled-market',
};

// Fetch current season's dungeon list dynamically from Blizzard API
async function fetchCurrentSeasonDungeons() {
  try {
    const host = BLIZZARD_API_HOSTS['us'];
    // Get current season ID
    const seasonIndex = await fetchBlizzardApi(
      `https://${host}/data/wow/mythic-keystone/season/index?namespace=dynamic-us&locale=en_US`
    );
    const currentSeason = seasonIndex?.current_season?.id || seasonIndex?.seasons?.[seasonIndex.seasons.length - 1]?.id;
    if (!currentSeason) return null;

    // Get season detail ‚Äî contains periods with dungeon references
    const seasonDetail = await fetchBlizzardApi(
      `https://${host}/data/wow/mythic-keystone/season/${currentSeason}?namespace=dynamic-us&locale=en_US`
    );

    // Get current period to find the active dungeons
    const periodIndex = await fetchBlizzardApi(
      `https://${host}/data/wow/mythic-keystone/period/index?namespace=dynamic-us&locale=en_US`
    );
    const currentPeriodId = periodIndex?.current_period?.id;

    // Try to get the current period's leaderboard index ‚Äî this lists only the active season dungeons
    if (currentPeriodId) {
      try {
        // The connected-realm leaderboard index lists current dungeons
        // Use connected realm 11 (Stormrage, a large US realm) as a reference
        const lbIndex = await fetchBlizzardApi(
          `https://${host}/data/wow/connected-realm/11/mythic-leaderboard/index?namespace=dynamic-us&locale=en_US`
        );
        if (lbIndex?.current_leaderboards?.length) {
          const dungeons = [];
          const seen = new Set();
          for (const lb of lbIndex.current_leaderboards) {
            const name = lb.name || '';
            if (!name || seen.has(name)) continue;
            seen.add(name);
            const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
            const short = name.split(/[\s:,!]+/).filter(w=>w).map(w => w[0]).join('').toUpperCase().substring(0, 5);
            dungeons.push({ slug, name, short, timer: 2100 });
          }
          if (dungeons.length >= 4 && dungeons.length <= 12) {
            // Now fetch individual dungeon details for accurate timers (only 8ish calls)
            for (let i = 0; i < dungeons.length; i++) {
              const lb = lbIndex.current_leaderboards.find(l => l.name === dungeons[i].name);
              if (lb?.id) {
                try {
                  const detail = await fetchBlizzardApi(
                    `https://${host}/data/wow/mythic-keystone/dungeon/${lb.id}?namespace=dynamic-us&locale=en_US`
                  );
                  if (detail.keystone_upgrades?.[0]?.qualifying_duration) {
                    dungeons[i].timer = Math.round(detail.keystone_upgrades[0].qualifying_duration / 1000);
                  }
                } catch(e) { /* use default timer */ }
              }
            }
            return { dungeons, seasonId: currentSeason, seasonName: seasonDetail?.season_name || null };
          }
        }
      } catch(e) {}
    }

    return { dungeons: [], seasonId: currentSeason, seasonName: seasonDetail?.season_name || null };
  } catch(e) {}
  return null;
}

function getDungeonIcon(slug) {
  const imageSlug = DUNGEON_IMAGE_SLUGS[slug] || slug;
  return `https://render.worldofwarcraft.com/us/zones/${imageSlug}-small.jpg`;
}

function calcRunScore(keyLevel, stars) {
  // Estimate Blizzard's M+ rating for path-finding predictions (actual runs use map_rating.rating)
  // Base score: 155 at key 2, ~485 at key 20 (per mythicplanner.com)
  if (keyLevel < 2) return 0;
  const base = 155 + (keyLevel - 2) * 18.33;
  // Stars approximate completion time relative to timer:
  // 3 = ~60% of timer (PT‚âà0.40), 2 = ~80% (PT‚âà0.20), 1 = just timed (PT‚âà0.05), 0 = overtime
  // bonus = min(PT, 0.40) * 37.5, overtime penalty = -15
  if (stars >= 3) return base + 15;    // 0.40 * 37.5
  if (stars >= 2) return base + 7.5;   // 0.20 * 37.5
  if (stars >= 1) return base + 1.875; // 0.05 * 37.5
  return Math.max(base - 15, 0);       // overtime penalty
}



function formatTime(sec) {
  return `${Math.floor(sec / 60)}:${String(Math.round(sec % 60)).padStart(2, '0')}`;
}

function getAffixesForLevel(kl) {
  const a = [];
  if (kl >= 2) a.push("Xal'atath's Bargain");
  if (kl >= 4) a.push('Tyrannical');
  if (kl >= 7) a.push("Challenger's Peril");
  if (kl >= 10) a.push('Fortified');
  if (kl >= 12) { const i = a.indexOf("Challenger's Peril"); if (i > -1) a.splice(i, 1, "Challenger's Bane"); }
  return a;
}

// Fetch from Blizzard API through our proxy (handles OAuth2 server-side)
async function fetchBlizzardApi(url) {
  const isLocal = window.location.hostname === 'localhost' ||
                  window.location.hostname === '127.0.0.1';

  // Local dev server proxy
  if (isLocal) {
    const proxyUrl = '/api/blizzard?url=' + encodeURIComponent(url);
    const resp = await fetch(proxyUrl);
    if (!resp.ok) {
      const err = await resp.json().catch(() => ({ error: `HTTP ${resp.status}` }));
      throw new Error(err.error || `API error ${resp.status}`);
    }
    return resp.json();
  }

  // GitHub Pages ‚Üí Cloudflare Worker proxy
  if (window.location.hostname.endsWith('.github.io')) {
    const workerProxy = 'https://syrs-mplus-helper-proxy.diabtraders.workers.dev?url=' + encodeURIComponent(url);
    const resp = await fetch(workerProxy);
    if (!resp.ok) {
      const err = await resp.json().catch(() => ({ error: `HTTP ${resp.status}` }));
      throw new Error(err.error || `API error ${resp.status}`);
    }
    return resp.json();
  }

  // Vercel serverless proxy
  try {
    const vercelProxy = '/api/proxy?url=' + encodeURIComponent(url);
    const resp = await fetch(vercelProxy);
    if (resp.ok) return resp.json();
  } catch (e) {}

  throw new Error('No API proxy available. Run the local server with: python server.py');
}

// Absolute thresholds for overall M+ rating display
function getScoreColor(s) {
  if (s >= 2500) return '#ff8000';
  if (s >= 2000) return '#a335ee';
  if (s >= 1500) return '#0070dd';
  if (s >= 1000) return '#1eff00';
  if (s >= 500) return '#ffffff';
  return '#9d9d9d';
}

function getClassColor(className) {
  const classColors = {
    'Death Knight': '#c41e3a',
    'Demon Hunter': '#a335ee',
    'Druid': '#ff7d0a',
    'Evoker': '#33937f',
    'Hunter': '#aad372',
    'Mage': '#69ccf0',
    'Monk': '#00ff98',
    'Paladin': '#f58cba',
    'Priest': '#c0c0c0',
    'Rogue': '#fff569',
    'Shaman': '#0070dd',
    'Warlock': '#9482ca',
    'Warrior': '#c79c6e',
  };
  return classColors[className] || '#a1a2a6';
}

// Rank-based 8-point color gradient for per-dungeon scores
// Each unique score is assigned to one of 8 equally-spaced color stops
function getDungeonScoreColor(score, allScores, scoreIndex) {
  // User-provided colors for scores 1-8
  const colorMap = {
    1: 'rgb(28, 183, 61)',
    2: 'rgb(12, 156, 176)',
    3: 'rgb(70, 98, 247)',
    4: 'rgb(124, 61, 255)',
    5: 'rgb(184, 29, 227)',
    6: 'rgb(213, 72, 177)',
    7: 'rgb(242, 107, 98)',
    8: 'rgb(225, 168, 23)',
  };
  if (score <= 0) return '#9d9d9d';
  // If we have a scoreIndex (for path rows showing suggested score), use that
  if (scoreIndex !== undefined && scoreIndex >= 1 && scoreIndex <= 8) {
    return colorMap[scoreIndex];
  }
  // Otherwise, rank among unique scores and map to color index
  const vals = allScores.filter(v => v > 0);
  if (!vals.length) return '#9d9d9d';
  const unique = [...new Set(vals)].sort((a, b) => a - b);
  const rank = unique.indexOf(score);
  if (rank === -1) return '#9d9d9d';
  const colorIdx = Math.max(1, Math.min(8, unique.length <= 1 ? 4 : Math.round(rank / (unique.length - 1) * 7) + 1));
  return colorMap[colorIdx];
}

// Build dungeon state from Blizzard API best_runs
function buildDungeonState(bestRuns, dungeonList) {
  const st = {};
  dungeonList.forEach(d => {
    st[d.slug] = {
      name: d.name, slug: d.slug, short: d.short, timer: d.timer,
      icon: getDungeonIcon(d.slug),
      best: { score: 0, keyLevel: 0, stars: 0 },
      totalScore: 0,
    };
  });
  (bestRuns || []).forEach(run => {
    const dungeonName = run.dungeon?.name || '';
    const dungeonSlug = dungeonName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
    const key = Object.keys(st).find(k =>
      k === dungeonSlug ||
      st[k].name.toLowerCase() === dungeonName.toLowerCase() ||
      dungeonSlug.includes(k) || k.includes(dungeonSlug)
    );
    if (!key) return;
    const k = key;
    const kl = run.keystone_level || run.mythic_level || 0;
    const rs = run.map_rating?.rating || 0;
    // Calculate stars from duration vs dungeon timer (API keystone_upgrades is just 0/1)
    const durationMs = run.duration || 0;
    const timerMs = (st[k].timer || 2100) * 1000;
    let stars = 0;
    if (durationMs > 0 && timerMs > 0) {
      if (durationMs <= timerMs * 0.6) stars = 3;
      else if (durationMs <= timerMs * 0.8) stars = 2;
      else if (durationMs <= timerMs) stars = 1;
    } else if (run.keystone_upgrades > 0 || run.is_completed_within_time) {
      stars = 1; // fallback if no duration data
    }
    // Keep the run with the highest rating; prefer timed runs (stars>0) when ratings are equal
    if (rs > st[k].best.score || (rs === st[k].best.score && stars > st[k].best.stars)) {
      st[k].best = { score: rs, keyLevel: kl, stars };
    }
  });
  // totalScore = best run's rating directly (no more fort/tyran multiplier)
  Object.keys(st).forEach(k => { st[k].totalScore = Math.round(st[k].best.score * 10) / 10; });
  return st;
}

function findPaths(ds, target, current, con, keys) {
  const diff = target - current;
  if (diff <= 0) return { quickest: [], easiest: [] };
  const cands = [];
  const dungeons = Object.values(ds).filter(d => !con.allowedDungeons?.length || con.allowedDungeons.includes(d.slug));
  const mk = con.maxKeyLevel || 30;
  // Calculate character's max key level to limit star suggestions
  const charMaxKey = Math.max(...dungeons.map(d => d.best.keyLevel || 0), 2);
  dungeons.forEach(d => {
    const cur = d.best;
    for (let kl = 2; kl <= mk; kl++) {
      // Only suggest 3-star if 10+ levels below max, 2-star if 5+ levels below
      const levelsBelow = charMaxKey - kl;
      let maxStars = 1;
      if (levelsBelow >= 10) maxStars = 3;
      else if (levelsBelow >= 5) maxStars = 2;
      for (let s = 1; s <= maxStars; s++) {
        const ns = calcRunScore(kl, s);
        if (ns <= cur.score) continue;
        const gain = Math.round((ns - cur.score) * 10) / 10;
        if (gain <= 0) continue;
        const tl = d.timer || 2100;
        cands.push({
          dungeon: d.name, slug: d.slug, short: d.short, icon: d.icon,
          keyLevel: kl, stars: s, runScore: ns, scoreGain: gain,
          estTime: Math.round(s === 3 ? tl * 0.55 : s === 2 ? tl * 0.75 : tl * 0.95),
          timerLimit: tl, affixes: getAffixesForLevel(kl),
        });
      }
    }
  });
  let fc = cands;
  if (con.useKeystones && keys?.length) fc = cands.filter(c => keys.some(k => k.slug === c.slug && k.level === c.keyLevel));
  const quickest = greedyPath(fc, diff);
  const quickestMaxKey = Math.max(...quickest.map(r => r.keyLevel), 0);
  // Easiest: find the lowest max key level cap that can reach the target
  let easiest = [];
  for (let cap = 2; cap < quickestMaxKey; cap++) {
    const capped = fc.filter(c => c.keyLevel <= cap);
    const bestPerDungeon = {};
    capped.forEach(c => {
      if (!bestPerDungeon[c.slug] || c.scoreGain > bestPerDungeon[c.slug].scoreGain)
        bestPerDungeon[c.slug] = c;
    });
    if (Object.values(bestPerDungeon).reduce((s, c) => s + c.scoreGain, 0) >= diff) {
      easiest = greedyPath(capped, diff);
      if (easiest.length) break;
    }
  }
  if (!easiest.length) easiest = quickest;
  return { quickest, easiest };
}

function greedyPath(cs, diff) {
  if (!cs.length) return [];

  // Step 1: Pick dungeons by highest gain first (fewest runs needed)
  // For easiest, candidates are already pre-filtered to lower key levels by the caller
  const sorted = [...cs].sort((a, b) => b.scoreGain - a.scoreGain || a.keyLevel - b.keyLevel);
  const path = [], used = {};
  let rem = diff;
  for (const c of sorted) {
    if (rem <= 0) break;
    if (used[c.slug]) continue;
    path.push({ ...c }); rem -= c.scoreGain; used[c.slug] = true;
  }
  if (!path.length || rem > 0) return [];

  // Step 2: Lower each dungeon to the minimum key level that still meets the target
  const byDungeon = {};
  cs.forEach(c => {
    if (!used[c.slug]) return;
    if (!byDungeon[c.slug]) byDungeon[c.slug] = [];
    byDungeon[c.slug].push(c);
  });
  for (const slug of Object.keys(byDungeon)) {
    byDungeon[slug].sort((a, b) => a.keyLevel - b.keyLevel || a.stars - b.stars);
  }
  let total = path.reduce((s, c) => s + c.scoreGain, 0);
  for (let i = 0; i < path.length; i++) {
    const options = byDungeon[path[i].slug];
    if (!options) continue;
    for (const opt of options) {
      if (opt.keyLevel >= path[i].keyLevel) break;
      if (total - path[i].scoreGain + opt.scoreGain >= diff) {
        total = total - path[i].scoreGain + opt.scoreGain;
        path[i] = { ...opt };
        break;
      }
    }
  }

  return path;
}

function saveToCookies(s) { try { document.cookie = `syrmplus_searches=${encodeURIComponent(JSON.stringify(s))}; expires=${new Date(Date.now()+7776e6).toUTCString()}; path=/; SameSite=Lax`; } catch(e){} }
function loadFromCookies() { try { const m = document.cookie.match(/syrmplus_searches=([^;]+)/); return m ? JSON.parse(decodeURIComponent(m[1])) : []; } catch(e){ return []; } }
function saveFormFieldsToCookies(charName, realm, region) { try { const data = { charName, realm, region }; document.cookie = `syrmplus_form=${encodeURIComponent(JSON.stringify(data))}; expires=${new Date(Date.now()+7776e6).toUTCString()}; path=/; SameSite=Lax`; } catch(e){} }
function loadFormFieldsFromCookies() { try { const m = document.cookie.match(/syrmplus_form=([^;]+)/); return m ? JSON.parse(decodeURIComponent(m[1])) : null; } catch(e){ return null; } }
function clearCookies() { document.cookie = 'syrmplus_searches=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;'; }

function RealmAutocomplete({ value, onChange, region, realmsData, onSubmit }) {
  const [open, setOpen] = useState(false);
  const [idx, setIdx] = useState(-1);
  const ref = useRef(null);
  const realms = realmsData[region] || [];
  const filtered = useMemo(() => {
    if (!value || value.length < 1) return [];
    const q = value.toLowerCase().replace(/['\s-]/g, '');
    return realms.filter(r => {
      const n = r.name.toLowerCase().replace(/['\s-]/g, '');
      const s = (r.slug||'').toLowerCase().replace(/['\s-]/g, '');
      return n.includes(q) || s.includes(q);
    }).slice(0, 12);
  }, [value, realms]);
  useEffect(() => { setIdx(-1); }, [filtered]);
  useEffect(() => {
    const h = (e) => { if (ref.current && !ref.current.contains(e.target)) setOpen(false); };
    document.addEventListener('mousedown', h);
    return () => document.removeEventListener('mousedown', h);
  }, []);
  const select = (r) => { onChange(r.name); setOpen(false); };
  const highlight = (text) => {
    if (!value) return text;
    const q = value.trim().toLowerCase();
    const low = text.toLowerCase();
    const i = low.indexOf(q);
    if (i === -1) return text;
    return [text.slice(0, i), <mark key="m">{text.slice(i, i + q.length)}</mark>, text.slice(i + q.length)];
  };
  return (
    <div className="input-group" ref={ref}>
      <label>Realm</label>
      <input className="input" placeholder="Start typing..." value={value} autoComplete="off"
        onChange={e => { onChange(e.target.value); setOpen(true); }}
        onFocus={() => { if (value.length >= 1) setOpen(true); }}
        onKeyDown={e => {
          if (e.key === 'ArrowDown' && open && filtered.length) { e.preventDefault(); setIdx(i => Math.min(i+1, filtered.length-1)); }
          else if (e.key === 'ArrowUp' && open && filtered.length) { e.preventDefault(); setIdx(i => Math.max(i-1, 0)); }
          else if (e.key === 'Enter') { if (open && idx >= 0) { e.preventDefault(); select(filtered[idx]); } else { setOpen(false); onSubmit?.(); } }
          else if (e.key === 'Escape') setOpen(false);
        }} />
      {open && filtered.length > 0 && (
        <div className="autocomplete-dropdown">
          {filtered.map((r, i) => (
            <div key={r.slug} className={`autocomplete-item ${i === idx ? 'active' : ''}`}
              onClick={() => select(r)} onMouseEnter={() => setIdx(i)}>
              {highlight(r.name)}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

function ThemeToggle({ theme, onToggle }) {
  return (
    <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
      <span className="theme-toggle-label">‚òÄÔ∏è</span>
      <div className={`theme-toggle ${theme}`} onClick={onToggle} />
      <span className="theme-toggle-label">üåô</span>
    </div>
  );
}

function PathRow({ dungeon, run, allScores, index }) {
  return (
    <div className="path-row fade-in" style={{ animationDelay: `${index*0.04}s` }}>
      <div className="path-current">
        <img className="path-thumb" src={dungeon.icon} alt={dungeon.name}
          onError={e=>{if(!e.target.dataset.errored){e.target.dataset.errored='true';e.target.src=`https://via.placeholder.com/40x40/2c2d33/5b9cf5?text=${encodeURIComponent(dungeon.short||'?')}`;}}}/>
        <div className="path-current-info">
          <div className="path-dungeon-name">{dungeon.name}</div>
        </div>
      </div>
      <div className="path-arrow-col">
        <span className="path-arrow-symbol">‚Üí</span>
      </div>
      <div className="path-suggest">
        <div className="path-suggest-run">
          <span className="path-key">+{run.keyLevel}</span>
          {run.stars > 0 && <span className="path-stars">{'‚òÖ'.repeat(run.stars)}</span>}
        </div>
        <span className="path-suggest-time">~{formatTime(run.estTime)} / {formatTime(run.timerLimit)}</span>
        <div className="path-suggest-gain">+{Math.round(run.scoreGain)}<span style={{fontSize:'11px',fontWeight:400,marginLeft:4,opacity:0.75}}>points</span></div>
      </div>
    </div>
  );
}

function CompactDungeonRow({ dungeon, allScores, index }) {
  return (
    <div className="compact-dungeon-row fade-in" style={{animationDelay:`${index*0.03}s`}}>
      <img className="compact-dungeon-thumb" src={dungeon.icon} alt={dungeon.name}
        onError={e=>{if(!e.target.dataset.errored){e.target.dataset.errored='true';e.target.src=`https://via.placeholder.com/36x36/2c2d33/5b9cf5?text=${encodeURIComponent(dungeon.short)}`;}}}/>
      <div className="compact-dungeon-info">
        <span className="compact-dungeon-name">{dungeon.name}</span>
        {dungeon.best.keyLevel > 0 ? (
          <div className="compact-dungeon-meta">
            <span className="compact-key-level">+{dungeon.best.keyLevel}</span>
            {dungeon.best.stars > 0 && <span className="compact-stars">{'‚òÖ'.repeat(dungeon.best.stars)}</span>}
          </div>
        ) : (
          <span style={{color:'var(--text-muted)',fontSize:11}}>‚Äî</span>
        )}
      </div>
      <span className="compact-score" style={{color:getDungeonScoreColor(dungeon.totalScore, allScores)}}>{dungeon.totalScore.toFixed(1)}</span>
    </div>
  );
}

function PrivacyModal({ onClose }) {
  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={e => e.stopPropagation()}>
        <h2>üç™ Privacy Policy ‚Äî Cookie Usage</h2>
        <p><strong>What we store:</strong> When you save a search, we store the character name, realm, region, target score, and constraint settings in a browser cookie on your device.</p>
        <p><strong>What we do NOT store:</strong> No personal information, email addresses, IP addresses, or analytics data. No login system, tracking, or third-party sharing.</p>
        <p><strong>How cookies work here:</strong> A single cookie (<code>syrmplus_searches</code>) remembers your past searches so you can quickly re-run them. It is stored entirely on YOUR device.</p>
        <p><strong>No server storage:</strong> All data stays in your browser. The only external requests go to the official Blizzard WoW API.</p>
        <p><strong>Deleting your data:</strong> Use "Clear All" in Saved Searches, or clear cookies in your browser settings.</p>
        <p><strong>Duration:</strong> Cookies expire after 90 days.</p>
        <p style={{ marginTop:16, paddingTop:12, borderTop:'1px solid var(--border)' }}><em>Last updated: {new Date().toLocaleDateString()}</em></p>
        <div style={{ marginTop:20, textAlign:'right' }}><button className="btn btn-primary" onClick={onClose}>Got it</button></div>
      </div>
    </div>
  );
}

function App() {
  const [theme, setTheme] = useState('dark');
  const [charName, setCharName] = useState('');
  const [realm, setRealm] = useState('');
  const [region, setRegion] = useState('us');
  const [targetScore, setTargetScore] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [charData, setCharData] = useState(null);
  const [dungeonState, setDungeonState] = useState(null);
  const [results, setResults] = useState(null);
  const [activeTab, setActiveTab] = useState('quickest');
  const [seasonName, setSeasonName] = useState('');
  const [currentSeasonId, setCurrentSeasonId] = useState(null);
  const [allowedDungeons, setAllowedDungeons] = useState([]);
  const [maxKeyLevel, setMaxKeyLevel] = useState('');
  const [advancedMode, setAdvancedMode] = useState(false);
  const [keystones, setKeystones] = useState([{ slug:'', level:'' }]);
  const [savedSearches, setSavedSearches] = useState([]);
  const [showPrivacy, setShowPrivacy] = useState(false);
  const [showSaved, setShowSaved] = useState(false);
  const [showDungeonFilter, setShowDungeonFilter] = useState(false);
  const [showKeystoneSection, setShowKeystoneSection] = useState(false);
  const [realmsData, setRealmsData] = useState({ us:[], eu:[], kr:[], tw:[] });
  const [realmsLoading, setRealmsLoading] = useState(true);
  const [dungeonList, setDungeonList] = useState(FALLBACK_DUNGEONS);
  const hasInitializedRef = useRef(false);

  useEffect(() => { document.body.setAttribute('data-theme', theme); }, [theme]);
  useEffect(() => { 
    setSavedSearches(loadFromCookies()); 
    const formFields = loadFormFieldsFromCookies();
    if (formFields) {
      setCharName(formFields.charName || '');
      setRealm(formFields.realm || '');
      setRegion(formFields.region || 'us');
    }
    hasInitializedRef.current = true;
  }, []);

  // Auto-save character when a successful lookup occurs
  useEffect(() => {
    if (hasInitializedRef.current && charData && !loading) {
      autoSaveCharacter();
    }
  }, [charData]);

  // Fetch realm lists and current season dungeons from Blizzard API on mount
  useEffect(() => {
    async function go() {
      setRealmsLoading(true);

      // Fetch realms for all regions
      const nd = { us:[], eu:[], kr:[], tw:[] };
      for (const r of ['us','eu','kr','tw']) {
        try {
          const host = BLIZZARD_API_HOSTS[r];
          const data = await fetchBlizzardApi(`https://${host}/data/wow/realm/index?namespace=dynamic-${r}&locale=en_US`);
          if (data.realms && data.realms.length) {
            nd[r] = data.realms
              .filter(x => x.name && x.slug
                && !/inst|auxiliary|test|tournament/i.test(x.name)
                && !/inst|auxiliary|test|tournament/i.test(x.slug)
                && !/^\d/.test(x.slug)
                && !/[A-Z]{2}\d/.test(x.name))
              .map(x => ({ name: x.name, slug: x.slug }))
              .sort((a,b) => a.name.localeCompare(b.name));
          }
        } catch(e) {
        }
        if (!nd[r] || nd[r].length === 0) nd[r] = FALLBACK_REALMS[r] || [];
      }
      setRealmsData(nd);

      // Fetch current season dungeon list dynamically
      try {
        const result = await fetchCurrentSeasonDungeons();
        if (result?.dungeons?.length) {
          setDungeonList(result.dungeons);
          if (result.seasonId) {
            setCurrentSeasonId(result.seasonId);
            setSeasonName(getSeasonDisplayName(result.seasonId));
          }
        }
      } catch(e) {
      }

      setRealmsLoading(false);
    }
    go();
  }, []);

  const toggleTheme = () => setTheme(t => t==='dark'?'light':'dark');
  const toggleDungeon = (slug) => setAllowedDungeons(p => p.includes(slug)?p.filter(s=>s!==slug):[...p,slug]);
  const addKeystone = () => setKeystones(p => [...p, {slug:'',level:''}]);
  const removeKeystone = (i) => setKeystones(p => p.filter((_,x)=>x!==i));
  const updateKeystone = (i,f,v) => setKeystones(p => p.map((k,x)=>x===i?{...k,[f]:v}:k));

  const getRealmSlug = (name) => {
    const rl = realmsData[region]||[];
    const f = rl.find(r => r.name.toLowerCase() === name.trim().toLowerCase());
    return f ? f.slug : name.trim().toLowerCase().replace(/'/g,'').replace(/\s+/g,'-');
  };

  async function lookupCharacter() {
    if (!charName.trim() || !realm.trim()) { setError('Please enter both character name and realm.'); return; }
    setLoading(true); setError(''); setCharData(null); setDungeonState(null); setResults(null);
    try {
      const slug = getRealmSlug(realm);
      const name = charName.trim().toLowerCase();
      const host = BLIZZARD_API_HOSTS[region];
      const ns = `profile-${region}`;

      // Fetch character profile
      const profile = await fetchBlizzardApi(
        `https://${host}/profile/wow/character/${encodeURIComponent(slug)}/${encodeURIComponent(name)}?namespace=${ns}&locale=en_US`
      );

      // Fetch M+ keystone profile to get current rating and season list
      let mpProfile = null;
      try {
        mpProfile = await fetchBlizzardApi(
          `https://${host}/profile/wow/character/${encodeURIComponent(slug)}/${encodeURIComponent(name)}/mythic-keystone-profile?namespace=${ns}&locale=en_US`
        );
      } catch(e) {}

      // Get the current/latest season's best runs
      let seasonData = null;
      let charSeasonId = null;

      // Log available seasons for debugging
      if (mpProfile?.seasons?.length) {
        const seasonIds = mpProfile.seasons.map(s => s.id);

        // Prefer the known current season if the character has data for it
        if (currentSeasonId && seasonIds.includes(currentSeasonId)) {
          charSeasonId = currentSeasonId;
        } else {
          // Otherwise pick the highest season ID (most recent)
          charSeasonId = Math.max(...seasonIds);
        }
      }
      if (charSeasonId) {
        try {
          seasonData = await fetchBlizzardApi(
            `https://${host}/profile/wow/character/${encodeURIComponent(slug)}/${encodeURIComponent(name)}/mythic-keystone-profile/season/${charSeasonId}?namespace=${ns}&locale=en_US`
          );
        } catch(e) {}
      }

      // Fetch character media for avatar
      let mediaData = null;
      try {
        mediaData = await fetchBlizzardApi(
          `https://${host}/profile/wow/character/${encodeURIComponent(slug)}/${encodeURIComponent(name)}/character-media?namespace=${ns}&locale=en_US`
        );
      } catch(e) {}

      // Transform into app-compatible format
      const avatarAsset = mediaData?.assets?.find(a => a.key === 'avatar');
      const mpRating = seasonData?.mythic_rating?.rating || mpProfile?.current_mythic_rating?.rating || 0;

      const charInfo = {
        name: profile.name,
        realm: profile.realm?.name || realm,
        region: region,
        class: profile.character_class?.name || '',
        active_spec_name: profile.active_spec?.name || '',
        thumbnail_url: avatarAsset?.value || null,
        mythic_plus_scores_by_season: [{ season: `season-${charSeasonId || 'current'}`, scores: { all: mpRating } }],
      };
      setCharData(charInfo);
      if (charSeasonId) setSeasonName(getSeasonDisplayName(charSeasonId));

      // Build dungeon state from best runs, using the already-loaded dungeon list
      const bestRuns = seasonData?.best_runs || [];
      const newDungeonState = buildDungeonState(bestRuns, dungeonList);
      setDungeonState(newDungeonState);
      return { newDungeonState, charInfo };
    } catch(e) {
      if (e.message?.includes('NetworkError') || e.message?.includes('Failed to fetch') || (e.name==='TypeError' && e.message?.includes('fetch')))
        setError('Network error ‚Äî make sure python server.py is running with Blizzard API credentials.');
      else setError(e.message || 'Failed to look up character.');
    } finally { setLoading(false); }
  }

  function calculatePaths(ds = dungeonState, cd = charData) {
    if (!ds) return;
    const t = parseInt(targetScore)||0, c = cd?.mythic_plus_scores_by_season?.[0]?.scores?.all || 0;
    if (t <= c) { setError('Target score must be higher than current score.'); return; }
    setError('');
    const con = { allowedDungeons:allowedDungeons.length?allowedDungeons:null, maxKeyLevel:maxKeyLevel?parseInt(maxKeyLevel):null, useKeystones:advancedMode };
    const ks = advancedMode ? keystones.filter(k=>k.slug&&k.level).map(k=>({slug:k.slug,level:parseInt(k.level)})) : null;
    const r = findPaths(ds, t, c, con, ks);
    setResults(r);
    setActiveTab('quickest');
    const totalGain = (r.quickest||[]).reduce((s,x) => s + x.scoreGain, 0);
    if (totalGain < t - c) {
      setError('Your current filters cannot reach the target score. Try raising the max key level or enabling more dungeons.');
    }
  }

  async function handleSubmit() {
    const charChanged = charData && (charName.trim().toLowerCase() !== charData.name.toLowerCase() || realm.trim().toLowerCase() !== charData.realm.toLowerCase());
    if (charChanged || !dungeonState) {
      const result = await lookupCharacter();
      if (result && targetScore) calculatePaths(result.newDungeonState, result.charInfo);
    } else {
      calculatePaths();
    }
  }

  function saveSearch() {
    const newSearch = { id:Date.now(), charName:charName.trim(), realm:realm.trim(), region, targetScore, allowedDungeons:[...allowedDungeons], maxKeyLevel, advancedMode, keystones:advancedMode?[...keystones]:[], savedAt:new Date().toISOString() };
    // Check if this search already exists
    const isDuplicate = savedSearches.some(s => 
      s.charName === newSearch.charName && 
      s.realm === newSearch.realm && 
      s.region === newSearch.region && 
      s.targetScore === newSearch.targetScore && 
      JSON.stringify(s.allowedDungeons) === JSON.stringify(newSearch.allowedDungeons) &&
      s.maxKeyLevel === newSearch.maxKeyLevel &&
      s.advancedMode === newSearch.advancedMode
    );
    if (isDuplicate) { setError('This search has already been saved.'); return; }
    const u = [newSearch,...savedSearches].slice(0,10); setSavedSearches(u); saveToCookies(u);
  }

  function autoSaveCharacter() {
    const charNameTrim = charName.trim();
    const realmTrim = realm.trim();
    // Check if this character already exists in saved searches - if so, remove the old one
    const existingIndex = savedSearches.findIndex(s => 
      s.charName === charNameTrim && 
      s.realm === realmTrim && 
      s.region === region
    );
    let updatedSearches;
    if (existingIndex !== -1) {
      // Replace the existing entry
      updatedSearches = [...savedSearches];
      updatedSearches.splice(existingIndex, 1);
      updatedSearches = [{ id:Date.now(), charName:charNameTrim, realm:realmTrim, region, targetScore:'', allowedDungeons:[], maxKeyLevel:'', advancedMode:false, keystones:[], savedAt:new Date().toISOString() }, ...updatedSearches];
    } else {
      // Add new entry
      updatedSearches = [{ id:Date.now(), charName:charNameTrim, realm:realmTrim, region, targetScore:'', allowedDungeons:[], maxKeyLevel:'', advancedMode:false, keystones:[], savedAt:new Date().toISOString() }, ...savedSearches].slice(0,10);
    }
    setSavedSearches(updatedSearches);
    saveToCookies(updatedSearches);
    saveFormFieldsToCookies(charNameTrim, realmTrim, region);
  }
  function loadSearch(s) {
    setCharName(s.charName); setRealm(s.realm); setRegion(s.region);
    setTargetScore(s.targetScore||''); setAllowedDungeons(s.allowedDungeons||[]);
    setMaxKeyLevel(s.maxKeyLevel||''); setAdvancedMode(s.advancedMode||false);
    setKeystones(s.keystones?.length?s.keystones:[{slug:'',level:''}]); setShowSaved(false);
  }
  function deleteSaved(id) { const u=savedSearches.filter(s=>s.id!==id); setSavedSearches(u); saveToCookies(u); }
  function clearAllSaved() { setSavedSearches([]); clearCookies(); }

  const cs = charData?.mythic_plus_scores_by_season?.[0]?.scores?.all||0;
  const av = charData?.thumbnail_url;

  const formatSeasonName = (s) => {
    if (!s) return '';
    // Handle both "TWW Season 2" and "season-tww-2" formats
    if (s.startsWith('TWW')) return s;
    return s.replace(/-/g,' ').replace('season tww ','TWW Season ').replace('season df ','DF Season ').replace('season ','Season ').replace(/\b\w/g,c=>c.toUpperCase());
  };

  const allScores = dungeonState ? Object.values(dungeonState).map(d => d.totalScore) : [];
  const sortedDungeons = dungeonState ? Object.values(dungeonState).sort((a, b) => a.totalScore - b.totalScore) : [];

  return (
    <div>
      <header className="header">
        <div className="container header-inner">
          <div className="logo">
            <div className="logo-icon">S</div>
            <h1><span>Syr's</span> M+ Score Goal Helper</h1>
          </div>
          <div className="header-actions">
            <div style={{position:'relative'}}>
              <button className="btn btn-ghost btn-sm" onClick={()=>setShowSaved(!showSaved)}>üìã Saved ({savedSearches.length})</button>
              {showSaved && (
                <div style={{position:'absolute',top:'100%',right:0,background:'var(--bg-card)',border:'1px solid var(--border)',borderRadius:'var(--radius-sm)',marginTop:4,minWidth:300,maxHeight:400,overflowY:'auto',boxShadow:'var(--shadow)',zIndex:100}}>
                  {savedSearches.length === 0 ? (
                    <div style={{padding:16,textAlign:'center',color:'var(--text-muted)',fontSize:13}}>No saved searches yet.</div>
                  ) : (
                    <div className="saved-list" style={{padding:8}}>
                      {savedSearches.map(s=>(
                        <div key={s.id} className="saved-item" style={{marginBottom:4}} onClick={()=>{loadSearch(s);setShowSaved(false);}}>
                          <div style={{flex:1,minWidth:0}}>
                            <div className="saved-item-name">{s.charName} ‚Äî {s.realm}</div>
                            <div className="saved-item-meta">Target: {s.targetScore||'‚Äî'} ¬∑ {s.region.toUpperCase()}</div>
                          </div>
                          <button className="btn btn-ghost btn-sm" onClick={e=>{e.stopPropagation();deleteSaved(s.id);}} style={{padding:'2px 6px'}}>‚úï</button>
                        </div>
                      ))}
                      {savedSearches.length>0&&<button className="btn btn-danger btn-sm" onClick={clearAllSaved} style={{width:'100%',marginTop:8}}>Clear All</button>}
                    </div>
                  )}
                </div>
              )}
            </div>
            <ThemeToggle theme={theme} onToggle={toggleTheme} />
          </div>
        </div>
      </header>
      <main className="container">
        {/* PRE-LOOKUP: centered search card */}
        {!charData && (
          <div style={{maxWidth:1000,margin:'0 auto'}}>
            <div className="section">
              <div className="card">
                <div style={{display:'flex',alignItems:'center',justifyContent:'space-between',marginBottom:16}}>
                  <div className="section-title" style={{margin:0}}><div className="dot" /> Character Lookup</div>
                  {seasonName && <div className="season-badge">üè∞ {formatSeasonName(seasonName)}</div>}
                </div>
                <div className="search-grid full-width" style={{gridTemplateColumns:'60px 1fr 1fr'}}>
                  <div className="input-group" style={{marginBottom:0}}>
                    <label>Region</label>
                    <select value={region} onChange={e=>setRegion(e.target.value)} style={{fontSize:'14px',padding:'8px 12px'}}>
                      {REGIONS.map(r=><option key={r.value} value={r.value}>{r.label}</option>)}
                    </select>
                  </div>
                  <RealmAutocomplete value={realm} onChange={setRealm} region={region} realmsData={realmsData} onSubmit={handleSubmit} />
                  <div className="input-group" style={{marginBottom:0}}>
                    <label>Character Name</label>
                    <input className="input" placeholder="e.g. Syrsjr" value={charName}
                      onChange={e=>{const v=e.target.value;setCharName(v?v[0].toUpperCase()+v.slice(1):v);}} onKeyDown={e=>e.key==='Enter'&&handleSubmit()} />
                  </div>
                </div>
                <button className="btn btn-lookup" onClick={lookupCharacter} disabled={loading} style={{width:'100%',marginTop:12}}>
                  {loading?'...':'Look Up'}
                </button>
                {realmsLoading && <div className="info-msg" style={{marginTop:12}}>Loading realm lists from Blizzard API...</div>}
              </div>
            </div>
            {loading && <div className="loading-spinner" />}
            {error && <div className="error-msg" style={{marginTop:16}}>{error}</div>}
          </div>
        )}

        {/* POST-LOOKUP: two-column layout */}
        {charData && (
          <div className="app-two-col">
            {/* LEFT PANEL: search, filters */}
            <div className="left-panel">
              <div className="card condensed-form" style={{padding:16,marginBottom:12}}>
                <div style={{display:'grid',gridTemplateColumns:'60px 1fr 1fr',gap:6,marginBottom:10}}>
                  <div className="input-group" style={{marginBottom:0}}>
                    <label>Region</label>
                    <select value={region} onChange={e=>setRegion(e.target.value)} style={{fontSize:'14px',padding:'8px 12px'}}>
                      {REGIONS.map(r=><option key={r.value} value={r.value}>{r.label}</option>)}
                    </select>
                  </div>
                  <RealmAutocomplete value={realm} onChange={setRealm} region={region} realmsData={realmsData} onSubmit={handleSubmit} />
                  <div className="input-group" style={{marginBottom:0}}>
                    <label>Character</label>
                    <input className="input" placeholder="Name" value={charName}
                      onChange={e=>{const v=e.target.value;setCharName(v?v[0].toUpperCase()+v.slice(1):v);}} onKeyDown={e=>e.key==='Enter'&&handleSubmit()} />
                  </div>
                </div>

                {/* Target score and Max Key Level on the same line */}
                <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:6,marginBottom:6}}>
                  <div className="input-group" style={{marginBottom:0}}>
                    <label>Target M+ Score</label>
                    <input className="input mono" type="number" step="1" placeholder="e.g. 2500" value={targetScore}
                      onChange={e=>setTargetScore(e.target.value)} onKeyDown={e=>{if(e.key==='.'||e.key===',')e.preventDefault(); else if(e.key==='Enter')handleSubmit();}} />
                  </div>
                  <div className="input-group" style={{marginBottom:0}}>
                    <label>Max Key Level</label>
                    <input className="input mono" type="number" step="1" placeholder="No limit" value={maxKeyLevel}
                      onChange={e=>setMaxKeyLevel(e.target.value)} onKeyDown={e=>{if(e.key==='.'||e.key===',')e.preventDefault(); else if(e.key==='Enter')handleSubmit();}} min="2" max="30" />
                  </div>
                </div>

                {/* Expandable: Limit to specific dungeons */}
                <div className="expandable-header" onClick={()=>setShowDungeonFilter(!showDungeonFilter)}>
                  <span className="expandable-icon">{showDungeonFilter?'‚àí':'+'}</span>
                  <span>Limit to specific dungeons</span>
                </div>
                <div className={`expandable-content${showDungeonFilter?' open':''}`}>
                  <div className="dungeon-checkboxes" style={{gridTemplateColumns:'1fr',marginBottom:4,paddingLeft:22}}>
                    {dungeonList.map(d=>(
                      <label key={d.slug} className="checkbox-label" style={{fontSize:14}}>
                        <input type="checkbox" checked={allowedDungeons.includes(d.slug)} onChange={()=>toggleDungeon(d.slug)} />
                        {d.name}
                      </label>
                    ))}
                  </div>
                </div>

                {/* Expandable: Restrict to specific keystones */}
                <div className="expandable-header" onClick={()=>{setShowKeystoneSection(!showKeystoneSection); setAdvancedMode(!showKeystoneSection);}}>
                  <span className="expandable-icon">{showKeystoneSection?'‚àí':'+'}</span>
                  <span>Restrict to specific keystones</span>
                </div>
                <div className={`expandable-content${showKeystoneSection?' open':''}`}>
                  <div style={{paddingLeft:22,marginBottom:4}}>
                    {keystones.map((k,i)=>(
                      <div key={i} style={{display:'flex',gap:4,marginBottom:4,alignItems:'center'}}>
                        <select value={k.slug} onChange={e=>updateKeystone(i,'slug',e.target.value)} style={{flex:1,fontSize:14,padding:'6px 8px'}}>
                          <option value="">Dungeon...</option>
                          {dungeonList.map(d=><option key={d.slug} value={d.slug}>{d.name}</option>)}
                        </select>
                        <input className="input mono" type="number" step="1" placeholder="+Lvl" value={k.level}
                          onChange={e=>updateKeystone(i,'level',e.target.value)} onKeyDown={e=>{if(e.key==='.'||e.key===',')e.preventDefault();}}
                          min="2" max="30" style={{width:50,fontSize:14,padding:'6px 8px'}} />
                        <button className="btn btn-ghost btn-sm" onClick={()=>removeKeystone(i)} style={{padding:'2px 6px',fontSize:12}}>‚úï</button>
                      </div>
                    ))}
                    <button className="btn btn-secondary btn-sm" onClick={addKeystone} style={{fontSize:11,padding:'4px 10px',marginTop:2}}>+ Add Key</button>
                  </div>
                </div>

                {/* Submit button at the very bottom */}
                <button className="btn btn-primary btn-sm" onClick={handleSubmit} disabled={!targetScore || !charName.trim() || !realm.trim()} style={{flex:1,width:'100%',marginTop:16}}>
                  Submit
                </button>
              </div>

              {/* Character info and current dungeon scores - only shown after paths are calculated */}
              {charData && dungeonState && results && (
                <div className="card" style={{padding:16}}>
                  {/* Character banner - no separate box */}
                  <div style={{display:'flex',alignItems:'center',gap:12,marginBottom:8}}>
                    {av && <img src={av} alt="avatar" style={{width:48,height:48,borderRadius:8,border:'2px solid var(--accent)',objectFit:'cover'}} onError={e=>{e.target.style.display='none';}} />}
                    <div style={{flex:1,minWidth:0}}>
                      <div style={{fontSize:16,fontWeight:700,color:'var(--text-primary)',marginBottom:2}}>{charData.name}</div>
                      <div style={{fontSize:12,color:'var(--text-muted)',marginBottom:2}}>{charData.realm} ‚Äî {charData.region?.toUpperCase()}</div>
                      <div style={{fontSize:12,color:'var(--text-secondary)',display:'flex',gap:0}}>
                        <span style={{color:getClassColor(charData.class)}}>{charData.active_spec_name} {charData.class}</span>
                      </div>
                    </div>
                    <div style={{textAlign:'right',flexShrink:0}}>
                      <div className="overall-score-num" style={{fontSize:24,fontWeight:700,color:getScoreColor(cs),fontFamily:"'Chivo Mono', monospace"}}>{cs.toFixed(1)}</div>
                    </div>
                  </div>
                  
                  {/* Current dungeon scores */}
                  <div style={{fontSize:12,fontWeight:600,color:'var(--text-secondary)',textTransform:'uppercase',letterSpacing:'0.5px',marginBottom:6}}>Current Scores</div>
                  {sortedDungeons.map((d,i)=>(
                    <CompactDungeonRow key={d.slug} dungeon={d} allScores={allScores} index={i} />
                  ))}
                </div>
              )}
            </div>

            {/* RIGHT PANEL: path results */}
            <div className="right-panel">
              {loading && <div className="loading-spinner" />}
              {error && <div className="error-msg" style={{marginBottom:16}}>{error}</div>}
              {results && !error.includes('cannot reach the target score') ? (() => {
                const currentPath = results[activeTab] || results.quickest || [];
                const sortedPath = [...currentPath].sort((a,b) => b.scoreGain - a.scoreGain);
                return (
                  <div className="section fade-in">
                    <div style={{display:'flex',alignItems:'center',justifyContent:'space-between',marginBottom:12}}>
                      <div className="section-title" style={{margin:0}}><div className="dot" /> Path to {targetScore}</div>
                      <div style={{fontSize:13,color:'var(--text-secondary)'}}>
                        Need <strong style={{color:'var(--success)'}}>+{(parseInt(targetScore)-cs).toFixed(0)}</strong> more
                      </div>
                    </div>
                    <div className="tabs" style={{marginBottom:16}}>
                      <button className={`tab ${activeTab==='quickest'?'active':''}`} onClick={()=>setActiveTab('quickest')}>‚ö° Quickest</button>
                      <button className={`tab ${activeTab==='easiest'?'active':''}`} onClick={()=>setActiveTab('easiest')}>üåø Easiest</button>
                    </div>
                    {sortedPath.length > 0 ? (
                      sortedPath.map((run,i) => {
                        const dungeon = dungeonState[run.slug];
                        if (!dungeon) return null;
                        return <PathRow key={run.slug} dungeon={dungeon} run={run} allScores={allScores} index={i} />;
                      })
                    ) : (
                      <div className="card" style={{textAlign:'center',padding:32,color:'var(--text-muted)',fontSize:14}}>
                        No path found. Try adjusting filters.
                      </div>
                    )}
                  </div>
                );
              })() : !results && dungeonState ? (
                <div className="card fade-in" style={{padding:24}}>
                  {/* Character banner ‚Äî larger display in the wide panel */}
                  <div style={{display:'flex',alignItems:'center',gap:16,marginBottom:20,paddingBottom:16,borderBottom:'1px solid var(--border)'}}>
                    {av && <img src={av} alt="avatar" style={{width:64,height:64,borderRadius:12,border:'2px solid var(--accent)',objectFit:'cover'}} onError={e=>{e.target.style.display='none';}} />}
                    <div style={{flex:1,minWidth:0}}>
                      <div style={{fontSize:22,fontWeight:700,color:'var(--text-primary)',marginBottom:2}}>{charData.name}</div>
                      <div style={{fontSize:13,color:'var(--text-muted)',marginBottom:2}}>{charData.realm} ‚Äî {charData.region?.toUpperCase()}</div>
                      <div style={{fontSize:13}}><span style={{color:getClassColor(charData.class)}}>{charData.active_spec_name} {charData.class}</span></div>
                      {seasonName && <div className="season-badge" style={{marginTop:6,display:'inline-flex'}}>{formatSeasonName(seasonName)}</div>}
                    </div>
                    <div style={{textAlign:'right',flexShrink:0}}>
                      <div className="overall-score-num" style={{fontSize:44,fontWeight:700,color:getScoreColor(cs),fontFamily:"'Chivo Mono',monospace",lineHeight:1}}>{cs.toFixed(1)}</div>
                      <div style={{fontSize:12,color:'var(--text-muted)',marginTop:4}}>M+ Score</div>
                    </div>
                  </div>
                  {/* Current dungeon scores in a 2-column grid */}
                  <div style={{fontSize:12,fontWeight:600,color:'var(--text-secondary)',textTransform:'uppercase',letterSpacing:'0.5px',marginBottom:8}}>Current Scores</div>
                  <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:6}}>
                    {sortedDungeons.map((d,i)=>(
                      <CompactDungeonRow key={d.slug} dungeon={d} allScores={allScores} index={i} />
                    ))}
                  </div>
                  <div className="info-msg" style={{marginTop:16,textAlign:'center'}}>
                    Enter a target score in the left panel and click <strong>Submit</strong> to see suggested paths.
                  </div>
                </div>
              ) : (
                <div style={{display:'flex',alignItems:'center',justifyContent:'center',minHeight:200,color:'var(--text-muted)',fontSize:14}}>
                  Enter a target score and click Submit to see suggested paths.
                </div>
              )}
            </div>
          </div>
        )}

        {/* Saved searches */}
        {showSaved && !charData && (
          <div style={{maxWidth:600,margin:'24px auto 0'}}>
            <div className="card">
              <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',marginBottom:16}}>
                <div className="section-title" style={{margin:0}}><div className="dot" /> Saved Searches</div>
                {savedSearches.length>0&&<button className="btn btn-danger btn-sm" onClick={clearAllSaved}>Clear All</button>}
              </div>
              {savedSearches.length===0 ? (
                <div style={{textAlign:'center',padding:24,color:'var(--text-muted)',fontSize:14}}>No saved searches yet.</div>
              ) : (
                <div className="saved-list">
                  {savedSearches.map(s=>(
                    <div key={s.id} className="saved-item" onClick={()=>loadSearch(s)}>
                      <div>
                        <div className="saved-item-name">{s.charName} ‚Äî {s.realm} ({s.region.toUpperCase()})</div>
                        <div className="saved-item-meta">Target: {s.targetScore||'‚Äî'} ¬∑ {new Date(s.savedAt).toLocaleDateString()}</div>
                      </div>
                      <button className="btn btn-ghost btn-sm" onClick={e=>{e.stopPropagation();deleteSaved(s.id);}}>‚úï</button>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        )}
      </main>
      <footer className="footer">
        <p>Syr's M+ Score Goal Helper ‚Äî Data from <a href="https://develop.battle.net/" target="_blank" rel="noopener noreferrer">Blizzard WoW API</a> ¬∑ <a onClick={()=>setShowPrivacy(true)}>Privacy Policy</a></p>
        <p style={{marginTop:4}}>Score calculations are approximate. Dungeon list and season update automatically from the API.</p>
      </footer>
      {showPrivacy && <PrivacyModal onClose={()=>setShowPrivacy(false)} />}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('app')).render(<App />);
</script>
</body>
</html>
