<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Syr's M+ Score Goal Helper</title>
<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Chivo+Mono:wght@400;500;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg-primary: #1a1b1e;
  --bg-secondary: #25262b;
  --bg-tertiary: #2c2d33;
  --bg-card: #2c2d33;
  --bg-input: #32333a;
  --bg-hover: #373840;
  --text-primary: #e4e5e7;
  --text-secondary: #a1a2a6;
  --text-muted: #6d6e73;
  --border: #3a3b42;
  --accent: #5b9cf5;
  --accent-hover: #4a8be4;
  --accent-dim: rgba(91,156,245,0.15);
  --success: #4ade80;
  --warning: #fbbf24;
  --danger: #f87171;
  --star1: #94a3b8;
  --star2: #fbbf24;
  --star3: #f97316;
  --shadow: 0 4px 24px rgba(0,0,0,0.3);
  --radius: 10px;
  --radius-sm: 6px;
  --transition: 0.2s ease;
}
[data-theme="light"] {
  --bg-primary: #f0f1f3;
  --bg-secondary: #ffffff;
  --bg-tertiary: #f7f8fa;
  --bg-card: #ffffff;
  --bg-input: #edeef0;
  --bg-hover: #e5e6e8;
  --text-primary: #1a1b1e;
  --text-secondary: #5c5d63;
  --text-muted: #9a9ba0;
  --border: #d8d9dd;
  --accent: #3b7de0;
  --accent-hover: #2a6ccf;
  --accent-dim: rgba(59,125,224,0.1);
  --shadow: 0 4px 24px rgba(0,0,0,0.08);
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Outfit', sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  min-height: 100vh;
  transition: background var(--transition), color var(--transition);
}
.mono { font-family: 'Chivo Mono', monospace; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--bg-primary); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
.container { max-width: 1100px; margin: 0 auto; padding: 0 20px; }
.header { padding: 24px 0; border-bottom: 1px solid var(--border); margin-bottom: 32px; }
.header-inner { display: flex; align-items: center; justify-content: space-between; }
.logo { display: flex; align-items: center; gap: 12px; }
.logo-icon {
  width: 36px; height: 36px; border-radius: 8px;
  background: linear-gradient(135deg, var(--accent), #8b5cf6);
  display: flex; align-items: center; justify-content: center;
  font-weight: 700; font-size: 16px; color: #fff;
}
.logo h1 { font-size: 20px; font-weight: 600; letter-spacing: -0.3px; }
.logo span { color: var(--accent); }
.header-actions { display: flex; align-items: center; gap: 12px; }
.theme-toggle {
  width: 52px; height: 28px; border-radius: 14px;
  background: var(--bg-input); border: 1px solid var(--border);
  cursor: pointer; position: relative; transition: all var(--transition);
}
.theme-toggle::after {
  content: ''; position: absolute; width: 22px; height: 22px;
  border-radius: 50%; background: var(--accent);
  top: 2px; left: 2px; transition: transform var(--transition);
}
.theme-toggle.light::after { transform: translateX(24px); }
.theme-toggle-label { font-size: 12px; color: var(--text-muted); }
.btn {
  padding: 10px 20px; border-radius: var(--radius-sm);
  font-family: 'Outfit', sans-serif; font-weight: 500; font-size: 14px;
  border: none; cursor: pointer; transition: all var(--transition);
  display: inline-flex; align-items: center; gap: 8px;
}
.btn-primary { background: var(--accent); color: #fff; }
.btn-primary:hover { background: var(--accent-hover); transform: translateY(-1px); }
.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
.btn-secondary { background: var(--bg-input); color: var(--text-primary); border: 1px solid var(--border); }
.btn-secondary:hover { background: var(--bg-hover); }
.btn-sm { padding: 6px 14px; font-size: 13px; }
.btn-ghost { background: transparent; color: var(--text-secondary); padding: 6px 10px; }
.btn-ghost:hover { color: var(--text-primary); background: var(--bg-hover); }
.btn-danger { background: transparent; color: var(--danger); }
.btn-danger:hover { background: rgba(248,113,113,0.1); }
.input-group { display: flex; flex-direction: column; gap: 6px; position: relative; }
.input-group label { font-size: 13px; font-weight: 500; color: var(--text-secondary); }
.input, select {
  padding: 10px 14px; border-radius: var(--radius-sm);
  background: var(--bg-input); border: 1px solid var(--border);
  color: var(--text-primary); font-family: 'Outfit', sans-serif;
  font-size: 14px; transition: all var(--transition); outline: none; width: 100%;
}
.input:focus, select:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-dim); }
select {
  cursor: pointer; appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%236d6e73' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat; background-position: right 12px center; padding-right: 32px;
}
.autocomplete-dropdown {
  position: absolute; top: 100%; left: 0; right: 0; z-index: 100;
  background: var(--bg-card); border: 1px solid var(--border);
  border-radius: var(--radius-sm); margin-top: 4px;
  max-height: 200px; overflow-y: auto; box-shadow: var(--shadow);
}
.autocomplete-item {
  padding: 8px 14px; cursor: pointer; font-size: 14px;
  color: var(--text-primary); transition: background 0.1s;
}
.autocomplete-item:hover, .autocomplete-item.active { background: var(--accent-dim); color: var(--accent); }
.autocomplete-item .realm-slug { font-size: 11px; color: var(--text-muted); margin-left: 6px; }
.autocomplete-item mark { background: transparent; color: var(--accent); font-weight: 600; }
.card {
  background: var(--bg-card); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 24px; transition: all var(--transition);
}
.search-grid { display: grid; grid-template-columns: 1fr 1fr 140px 120px; gap: 12px; align-items: end; }
.target-row { display: grid; grid-template-columns: 200px 1fr; gap: 12px; align-items: end; margin-top: 16px; }
.tabs { display: flex; gap: 4px; margin-bottom: 24px; }
.tab {
  padding: 10px 20px; border-radius: var(--radius-sm);
  background: transparent; color: var(--text-secondary);
  font-family: 'Outfit', sans-serif; font-weight: 500;
  font-size: 14px; border: none; cursor: pointer; transition: all var(--transition);
}
.tab:hover { color: var(--text-primary); background: var(--bg-hover); }
.tab.active { background: var(--accent); color: #fff; }
.dungeon-row {
  display: flex; align-items: center; gap: 16px;
  padding: 14px 16px; border-radius: var(--radius-sm);
  background: var(--bg-tertiary); border: 1px solid var(--border);
  margin-bottom: 8px; transition: all var(--transition);
}
.dungeon-row:hover { border-color: var(--accent); }
.dungeon-thumb {
  width: 48px; height: 48px; border-radius: 8px;
  object-fit: cover; flex-shrink: 0; border: 2px solid var(--border); background: var(--bg-input);
}
.dungeon-info { flex: 1; min-width: 0; }
.dungeon-name { font-weight: 600; font-size: 15px; margin-bottom: 2px; }
.dungeon-meta { font-size: 12px; color: var(--text-muted); display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
.dungeon-score-col { text-align: right; min-width: 80px; }
.dungeon-score { font-size: 20px; font-weight: 700; font-family: 'Chivo Mono', monospace; }
.dungeon-score-label { font-size: 11px; color: var(--text-muted); }
.star-badge {
  display: inline-flex; align-items: center; gap: 3px;
  padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600;
}
.star-1 { background: rgba(148,163,184,0.15); color: var(--star1); }
.star-2 { background: rgba(251,191,36,0.15); color: var(--star2); }
.star-3 { background: rgba(249,115,22,0.15); color: var(--star3); }
.key-level-badge {
  display: inline-flex; padding: 2px 8px; border-radius: 10px;
  font-size: 12px; font-weight: 600; background: var(--accent-dim); color: var(--accent);
  font-family: 'Chivo Mono', monospace;
}
.affix-badges { display: flex; gap: 4px; flex-wrap: wrap; }
.affix-badge {
  padding: 1px 6px; border-radius: 4px; font-size: 10px;
  background: var(--bg-hover); color: var(--text-secondary); border: 1px solid var(--border);
}
.time-info { font-size: 12px; color: var(--text-muted); font-family: 'Chivo Mono', monospace; }
.constraints-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 16px; }
.dungeon-checkboxes { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 8px; }
.checkbox-label {
  display: flex; align-items: center; gap: 8px;
  font-size: 13px; cursor: pointer; color: var(--text-secondary);
  padding: 4px 8px; border-radius: var(--radius-sm); transition: all var(--transition);
}
.checkbox-label:hover { background: var(--bg-hover); color: var(--text-primary); }
.checkbox-label input { accent-color: var(--accent); }
.keystone-grid { display: grid; grid-template-columns: 1fr 80px 60px; gap: 8px; align-items: center; margin-bottom: 6px; }
.path-summary {
  display: flex; gap: 16px; align-items: center;
  padding: 16px; background: var(--accent-dim);
  border-radius: var(--radius-sm); margin-bottom: 16px;
  border: 1px solid rgba(91,156,245,0.2);
}
.path-stat { text-align: center; }
.path-stat-value { font-size: 24px; font-weight: 700; color: var(--accent); font-family: 'Chivo Mono', monospace; }
.path-stat-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
.path-divider { width: 1px; height: 40px; background: var(--border); }
.score-delta { color: var(--success); }
.saved-list { display: flex; flex-direction: column; gap: 8px; }
.saved-item {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 14px; border-radius: var(--radius-sm);
  background: var(--bg-tertiary); border: 1px solid var(--border);
  cursor: pointer; transition: all var(--transition);
}
.saved-item:hover { border-color: var(--accent); }
.saved-item-name { font-weight: 500; font-size: 14px; }
.saved-item-meta { font-size: 12px; color: var(--text-muted); }
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.6);
  display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 20px;
}
.modal {
  background: var(--bg-card); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 32px;
  max-width: 560px; width: 100%; max-height: 80vh; overflow-y: auto;
}
.modal h2 { font-size: 20px; margin-bottom: 16px; }
.modal p { font-size: 14px; color: var(--text-secondary); line-height: 1.7; margin-bottom: 12px; }
.loading-spinner {
  width: 32px; height: 32px; border: 3px solid var(--border);
  border-top-color: var(--accent); border-radius: 50%;
  animation: spin 0.8s linear infinite; margin: 40px auto;
}
@keyframes spin { to { transform: rotate(360deg); } }
.error-msg {
  padding: 12px 16px; border-radius: var(--radius-sm);
  background: rgba(248,113,113,0.1); border: 1px solid rgba(248,113,113,0.2);
  color: var(--danger); font-size: 14px;
}
.info-msg {
  padding: 12px 16px; border-radius: var(--radius-sm);
  background: var(--accent-dim); border: 1px solid rgba(91,156,245,0.2);
  color: var(--accent); font-size: 13px;
}
.current-score-card { display: flex; align-items: center; gap: 20px; padding: 20px; margin-bottom: 24px; }
.avatar { width: 64px; height: 64px; border-radius: 12px; border: 2px solid var(--accent); object-fit: cover; }
.char-details { flex: 1; }
.char-name { font-size: 22px; font-weight: 700; }
.char-realm { font-size: 13px; color: var(--text-muted); }
.char-class { font-size: 13px; color: var(--text-secondary); margin-top: 2px; }
.current-score-display { text-align: right; }
.current-score-num {
  font-size: 36px; font-weight: 700; font-family: 'Chivo Mono', monospace;
  background: linear-gradient(135deg, var(--accent), #8b5cf6);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.current-score-label { font-size: 12px; color: var(--text-muted); }
.section { margin-bottom: 32px; }
.section-title {
  font-size: 16px; font-weight: 600; margin-bottom: 16px;
  display: flex; align-items: center; gap: 8px;
}
.section-title .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent); }
.toggle-row { display: flex; align-items: center; gap: 12px; margin-top: 16px; margin-bottom: 8px; }
.toggle-label { font-size: 14px; font-weight: 500; }
.season-badge {
  display: inline-flex; align-items: center; gap: 6px;
  padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 500;
  background: var(--accent-dim); color: var(--accent); border: 1px solid rgba(91,156,245,0.2);
}
.footer {
  margin-top: 48px; padding: 24px 0; border-top: 1px solid var(--border);
  text-align: center; font-size: 12px; color: var(--text-muted);
}
.footer a { color: var(--accent); text-decoration: none; cursor: pointer; }
.footer a:hover { text-decoration: underline; }
/* Two-column results layout */
.results-layout {
  display: grid; grid-template-columns: 1fr 320px; gap: 24px; align-items: start;
}
.results-main { min-width: 0; }
.results-sidebar { min-width: 0; }

/* Compact dungeon rows for sidebar */
.compact-dungeon-row {
  display: flex; align-items: center; gap: 10px;
  padding: 6px 10px; border-radius: var(--radius-sm);
  background: var(--bg-tertiary); border: 1px solid var(--border);
  margin-bottom: 4px; transition: all var(--transition);
}
.compact-dungeon-thumb {
  width: 36px; height: 36px; border-radius: 6px;
  object-fit: cover; flex-shrink: 0; border: 1px solid var(--border); background: var(--bg-input);
}
.compact-dungeon-info {
  flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 1px;
}
.compact-dungeon-name {
  font-weight: 600; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.compact-dungeon-meta {
  display: flex; align-items: center; gap: 6px;
}
.compact-key-level {
  font-size: 13px; font-weight: 700; font-family: 'Chivo Mono', monospace; color: var(--accent);
}
.compact-stars {
  color: #fbbf24; font-size: 12px; letter-spacing: 1px;
}
.compact-score {
  font-size: 14px; font-weight: 700; font-family: 'Chivo Mono', monospace;
  text-align: right; min-width: 45px; flex-shrink: 0;
}

@media (max-width: 768px) {
  .search-grid { grid-template-columns: 1fr 1fr; }
  .target-row { grid-template-columns: 1fr; }
  .constraints-grid { grid-template-columns: 1fr; }
  .dungeon-checkboxes { grid-template-columns: 1fr; }
  .path-summary { flex-wrap: wrap; }
  .header-inner { flex-wrap: wrap; gap: 12px; }
  .dungeon-row { flex-wrap: wrap; }
  .results-layout { grid-template-columns: 1fr; }
}
@keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
.fade-in { animation: fadeIn 0.3s ease forwards; }
</style>
</head>
<body data-theme="dark">
<div id="app"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<script type="text/babel">
const { useState, useEffect, useCallback, useRef, useMemo } = React;

const REGIONS = [
  { value: 'us', label: 'US' },
  { value: 'eu', label: 'EU' },
  { value: 'kr', label: 'KR' },
  { value: 'tw', label: 'TW' },
];

// Blizzard API region hosts
const BLIZZARD_API_HOSTS = {
  us: 'us.api.blizzard.com',
  eu: 'eu.api.blizzard.com',
  kr: 'kr.api.blizzard.com',
  tw: 'tw.api.blizzard.com',
};

// Map Blizzard internal season IDs to marketing names
const SEASON_NAMES = {
  13: 'TWW Season 1', 14: 'TWW Season 2', 15: 'TWW Season 3',
  16: 'TWW Season 4', 17: 'TWW Season 5',
};
function getSeasonDisplayName(id) {
  return SEASON_NAMES[id] || `Season ${id}`;
}

// Small offline fallback for realms so autocomplete works without API
const FALLBACK_REALMS = {
  us: [
    { name: 'Stormrage', slug: 'stormrage' },
    { name: 'Sargeras', slug: 'sargeras' },
    { name: 'Proudmoore', slug: 'proudmoore' },
    { name: 'Tichondrius', slug: 'tichondrius' },
    { name: 'Area 52', slug: 'area-52' },
    { name: 'Illidan', slug: 'illidan' },
    { name: 'Mal\'Ganis', slug: 'malganis' },
    { name: 'Thrall', slug: 'thrall' },
  ],
  eu: [
    { name: 'Silvermoon', slug: 'silvermoon' },
    { name: 'Ragnaros', slug: 'ragnaros' },
    { name: 'Draenor', slug: 'draenor' },
    { name: 'Kazzak', slug: 'kazzak' },
    { name: 'Twisting Nether', slug: 'twisting-nether' },
  ],
  kr: [ { name: 'Azshara', slug: 'azshara' }, { name: 'Hellscream', slug: 'hellscream' } ],
  tw: [ { name: 'Bleeding Hollow', slug: 'bleeding-hollow' }, { name: 'Sundown Marsh', slug: 'sundown-marsh' } ],
};

// TWW Season 3 dungeon pool (fallback if API returns no runs)
const FALLBACK_DUNGEONS = [
  { slug: 'eco-dome-aldani', name: "Eco-Dome Al'dani", short: 'ECO', timer: 1860 },
  { slug: 'ara-kara-city-of-echoes', name: 'Ara-Kara, City of Echoes', short: 'ARA', timer: 1800 },
  { slug: 'the-dawnbreaker', name: 'The Dawnbreaker', short: 'DAWN', timer: 1860 },
  { slug: 'priory-of-the-sacred-flame', name: 'Priory of the Sacred Flame', short: 'PSF', timer: 1950 },
  { slug: 'operation-floodgate', name: 'Operation: Floodgate', short: 'FLOOD', timer: 1980 },
  { slug: 'halls-of-atonement', name: 'Halls of Atonement', short: 'HOA', timer: 1860 },
  { slug: 'tazavesh-streets-of-wonder', name: 'Tazavesh: Streets of Wonder', short: 'STREETS', timer: 2340 },
  { slug: 'tazavesh-soleahs-gambit', name: "Tazavesh: So'leah's Gambit", short: 'GAMBIT', timer: 1800 },
];

// Map API-generated slugs to WoW armory image slugs (only entries that differ)
const DUNGEON_IMAGE_SLUGS = {
  'eco-dome-al-dani': 'eco-dome-aldani',
  'tazavesh-so-leah-s-gambit': 'tazavesh-the-veiled-market',
  'tazavesh-soleahs-gambit': 'tazavesh-the-veiled-market',
  'tazavesh-streets-of-wonder': 'tazavesh-the-veiled-market',
};

// Fetch current season's dungeon list dynamically from Blizzard API
async function fetchCurrentSeasonDungeons() {
  try {
    const host = BLIZZARD_API_HOSTS['us'];
    // Get current season ID
    const seasonIndex = await fetchBlizzardApi(
      `https://${host}/data/wow/mythic-keystone/season/index?namespace=dynamic-us&locale=en_US`
    );
    const currentSeason = seasonIndex?.current_season?.id || seasonIndex?.seasons?.[seasonIndex.seasons.length - 1]?.id;
    if (!currentSeason) return null;

    // Get season detail ‚Äî contains periods with dungeon references
    const seasonDetail = await fetchBlizzardApi(
      `https://${host}/data/wow/mythic-keystone/season/${currentSeason}?namespace=dynamic-us&locale=en_US`
    );

    // Get current period to find the active dungeons
    const periodIndex = await fetchBlizzardApi(
      `https://${host}/data/wow/mythic-keystone/period/index?namespace=dynamic-us&locale=en_US`
    );
    const currentPeriodId = periodIndex?.current_period?.id;

    // Try to get the current period's leaderboard index ‚Äî this lists only the active season dungeons
    if (currentPeriodId) {
      try {
        // The connected-realm leaderboard index lists current dungeons
        // Use connected realm 11 (Stormrage, a large US realm) as a reference
        const lbIndex = await fetchBlizzardApi(
          `https://${host}/data/wow/connected-realm/11/mythic-leaderboard/index?namespace=dynamic-us&locale=en_US`
        );
        if (lbIndex?.current_leaderboards?.length) {
          const dungeons = [];
          const seen = new Set();
          for (const lb of lbIndex.current_leaderboards) {
            const name = lb.name || '';
            if (!name || seen.has(name)) continue;
            seen.add(name);
            const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
            const short = name.split(/[\s:,!]+/).filter(w=>w).map(w => w[0]).join('').toUpperCase().substring(0, 5);
            dungeons.push({ slug, name, short, timer: 2100 });
          }
          if (dungeons.length >= 4 && dungeons.length <= 12) {
            // Now fetch individual dungeon details for accurate timers (only 8ish calls)
            for (let i = 0; i < dungeons.length; i++) {
              const lb = lbIndex.current_leaderboards.find(l => l.name === dungeons[i].name);
              if (lb?.id) {
                try {
                  const detail = await fetchBlizzardApi(
                    `https://${host}/data/wow/mythic-keystone/dungeon/${lb.id}?namespace=dynamic-us&locale=en_US`
                  );
                  if (detail.keystone_upgrades?.[0]?.qualifying_duration) {
                    dungeons[i].timer = Math.round(detail.keystone_upgrades[0].qualifying_duration / 1000);
                  }
                } catch(e) { /* use default timer */ }
              }
            }
            return { dungeons, seasonId: currentSeason, seasonName: seasonDetail?.season_name || null };
          }
        }
      } catch(e) {
        console.log('Leaderboard approach failed, using season periods:', e);
      }
    }

    // Fallback: extract dungeons from season detail periods if available
    if (seasonDetail?.periods?.length) {
      // Season periods list the dungeon rotation
      console.log('Season detail has', seasonDetail.periods.length, 'periods');
    }

    return { dungeons: [], seasonId: currentSeason, seasonName: seasonDetail?.season_name || null };
  } catch(e) {
    console.log('Failed to fetch current season dungeons:', e);
  }
  return null;
}

function getDungeonIcon(slug) {
  const imageSlug = DUNGEON_IMAGE_SLUGS[slug] || slug;
  return `https://render.worldofwarcraft.com/us/zones/${imageSlug}-small.jpg`;
}

function calcRunScore(keyLevel, stars) {
  // Estimate Blizzard's M+ rating for path-finding predictions (actual runs use map_rating.rating)
  // Base score: 155 at key 2, ~485 at key 20 (per mythicplanner.com)
  if (keyLevel < 2) return 0;
  const base = 155 + (keyLevel - 2) * 18.33;
  // Stars approximate completion time relative to timer:
  // 3 = ~60% of timer (PT‚âà0.40), 2 = ~80% (PT‚âà0.20), 1 = just timed (PT‚âà0.05), 0 = overtime
  // bonus = min(PT, 0.40) * 37.5, overtime penalty = -15
  if (stars >= 3) return base + 15;    // 0.40 * 37.5
  if (stars >= 2) return base + 7.5;   // 0.20 * 37.5
  if (stars >= 1) return base + 1.875; // 0.05 * 37.5
  return Math.max(base - 15, 0);       // overtime penalty
}



function formatTime(sec) {
  return `${Math.floor(sec / 60)}:${String(Math.round(sec % 60)).padStart(2, '0')}`;
}

function getAffixesForLevel(kl) {
  const a = [];
  if (kl >= 2) a.push("Xal'atath's Bargain");
  if (kl >= 4) a.push('Tyrannical');
  if (kl >= 7) a.push("Challenger's Peril");
  if (kl >= 10) a.push('Fortified');
  if (kl >= 12) { const i = a.indexOf("Challenger's Peril"); if (i > -1) a.splice(i, 1, "Challenger's Bane"); }
  return a;
}

// Fetch from Blizzard API through our proxy (handles OAuth2 server-side)
async function fetchBlizzardApi(url) {
  const isLocal = window.location.hostname === 'localhost' ||
                  window.location.hostname === '127.0.0.1';

  // Local dev server proxy
  if (isLocal) {
    const proxyUrl = '/api/blizzard?url=' + encodeURIComponent(url);
    const resp = await fetch(proxyUrl);
    if (!resp.ok) {
      const err = await resp.json().catch(() => ({ error: `HTTP ${resp.status}` }));
      throw new Error(err.error || `API error ${resp.status}`);
    }
    return resp.json();
  }

  // Vercel serverless proxy
  try {
    const vercelProxy = '/api/proxy?url=' + encodeURIComponent(url);
    const resp = await fetch(vercelProxy);
    if (resp.ok) return resp.json();
  } catch (e) {}

  throw new Error('No API proxy available. Run the local server with: python server.py');
}

function getScoreColor(s) {
  if (s >= 2500) return '#ff8000';
  if (s >= 2000) return '#a335ee';
  if (s >= 1500) return '#0070dd';
  if (s >= 1000) return '#1eff00';
  if (s >= 500) return '#ffffff';
  return '#9d9d9d';
}

// Build dungeon state from Blizzard API best_runs
function buildDungeonState(bestRuns, dungeonList) {
  const st = {};
  console.log('[debug] buildDungeonState: dungeonList slugs:', dungeonList.map(d => d.slug));
  dungeonList.forEach(d => {
    st[d.slug] = {
      name: d.name, slug: d.slug, short: d.short, timer: d.timer,
      icon: getDungeonIcon(d.slug),
      best: { score: 0, keyLevel: 0, stars: 0 },
      totalScore: 0,
    };
  });
  (bestRuns || []).forEach(run => {
    const dungeonName = run.dungeon?.name || '';
    const dungeonSlug = dungeonName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
    const key = Object.keys(st).find(k =>
      k === dungeonSlug ||
      st[k].name.toLowerCase() === dungeonName.toLowerCase() ||
      dungeonSlug.includes(k) || k.includes(dungeonSlug)
    );
    if (!key) {
      console.log(`[debug] NO MATCH for run dungeon "${dungeonName}" (slug: "${dungeonSlug}"). Known slugs:`, Object.keys(st));
      return;
    }
    const k = key;
    const kl = run.keystone_level || run.mythic_level || 0;
    const rs = run.map_rating?.rating || 0;
    // Calculate stars from duration vs dungeon timer (API keystone_upgrades is just 0/1)
    const durationMs = run.duration || 0;
    const timerMs = (st[k].timer || 2100) * 1000;
    let stars = 0;
    if (durationMs > 0 && timerMs > 0) {
      if (durationMs <= timerMs * 0.6) stars = 3;
      else if (durationMs <= timerMs * 0.8) stars = 2;
      else if (durationMs <= timerMs) stars = 1;
    } else if (run.keystone_upgrades > 0 || run.is_completed_within_time) {
      stars = 1; // fallback if no duration data
    }
    console.log(`[debug]   ${k}: level=${kl}, stars=${stars}, rating=${rs}, duration=${durationMs}ms, timer=${timerMs}ms`);
    // Keep the run with the highest rating; prefer timed runs (stars>0) when ratings are equal
    if (rs > st[k].best.score || (rs === st[k].best.score && stars > st[k].best.stars)) {
      st[k].best = { score: rs, keyLevel: kl, stars };
    }
  });
  // totalScore = best run's rating directly (no more fort/tyran multiplier)
  Object.keys(st).forEach(k => { st[k].totalScore = Math.round(st[k].best.score * 10) / 10; });
  return st;
}

function findPaths(ds, target, current, con, keys) {
  const diff = target - current;
  if (diff <= 0) return { quickest: [], easiest: [], balanced: [] };
  const cands = [];
  const dungeons = Object.values(ds).filter(d => !con.allowedDungeons?.length || con.allowedDungeons.includes(d.slug));
  const mk = con.maxKeyLevel || 30;
  dungeons.forEach(d => {
    const cur = d.best;
    for (let kl = Math.max(2, cur.keyLevel || 1); kl <= mk; kl++) {
      for (let s = 1; s <= 3; s++) {
        const ns = calcRunScore(kl, s);
        if (ns <= cur.score) continue;
        const gain = Math.round((ns - cur.score) * 10) / 10;
        if (gain <= 0) continue;
        const tl = d.timer || 2100;
        cands.push({
          dungeon: d.name, slug: d.slug, short: d.short, icon: d.icon,
          keyLevel: kl, stars: s, runScore: ns, scoreGain: gain,
          estTime: Math.round(s === 3 ? tl * 0.55 : s === 2 ? tl * 0.75 : tl * 0.95),
          timerLimit: tl, affixes: getAffixesForLevel(kl),
        });
      }
    }
  });
  let fc = cands;
  if (con.useKeystones && keys?.length) fc = cands.filter(c => keys.some(k => k.slug === c.slug && k.level === c.keyLevel));
  return { quickest: greedyPath(fc, diff, 'eff'), easiest: greedyPath(fc, diff, 'easy'), balanced: greedyPath(fc, diff, 'bal') };
}

function greedyPath(cs, diff, strat) {
  if (!cs.length) return [];
  let sorted;
  if (strat === 'eff') sorted = [...cs].sort((a, b) => b.scoreGain - a.scoreGain || a.keyLevel - b.keyLevel);
  else if (strat === 'easy') sorted = [...cs].sort((a, b) => a.keyLevel - b.keyLevel || b.scoreGain - a.scoreGain);
  else sorted = [...cs].sort((a, b) => (b.scoreGain / (b.keyLevel || 1)) - (a.scoreGain / (a.keyLevel || 1)));
  const path = [], used = {};
  let rem = diff;
  for (const c of sorted) {
    if (rem <= 0) break;
    if (used[c.slug]) continue;
    path.push({ ...c }); rem -= c.scoreGain; used[c.slug] = true;
  }
  return path;
}

function saveToCookies(s) { try { document.cookie = `syrmplus_searches=${encodeURIComponent(JSON.stringify(s))}; expires=${new Date(Date.now()+7776e6).toUTCString()}; path=/; SameSite=Lax`; } catch(e){} }
function loadFromCookies() { try { const m = document.cookie.match(/syrmplus_searches=([^;]+)/); return m ? JSON.parse(decodeURIComponent(m[1])) : []; } catch(e){ return []; } }
function clearCookies() { document.cookie = 'syrmplus_searches=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;'; }

function RealmAutocomplete({ value, onChange, region, realmsData }) {
  const [open, setOpen] = useState(false);
  const [idx, setIdx] = useState(-1);
  const ref = useRef(null);
  const realms = realmsData[region] || [];
  const filtered = useMemo(() => {
    if (!value || value.length < 1) return [];
    const q = value.toLowerCase().replace(/['\s-]/g, '');
    return realms.filter(r => {
      const n = r.name.toLowerCase().replace(/['\s-]/g, '');
      const s = (r.slug||'').toLowerCase().replace(/['\s-]/g, '');
      return n.includes(q) || s.includes(q);
    }).slice(0, 12);
  }, [value, realms]);
  useEffect(() => { setIdx(-1); }, [filtered]);
  useEffect(() => {
    const h = (e) => { if (ref.current && !ref.current.contains(e.target)) setOpen(false); };
    document.addEventListener('mousedown', h);
    return () => document.removeEventListener('mousedown', h);
  }, []);
  const select = (r) => { onChange(r.name); setOpen(false); };
  const highlight = (text) => {
    if (!value) return text;
    const q = value.trim().toLowerCase();
    const low = text.toLowerCase();
    const i = low.indexOf(q);
    if (i === -1) return text;
    return [text.slice(0, i), <mark key="m">{text.slice(i, i + q.length)}</mark>, text.slice(i + q.length)];
  };
  return (
    <div className="input-group" ref={ref}>
      <label>Realm</label>
      <input className="input" placeholder="Start typing..." value={value} autoComplete="off"
        onChange={e => { onChange(e.target.value); setOpen(true); }}
        onFocus={() => { if (value.length >= 1) setOpen(true); }}
        onKeyDown={e => {
          if (!open || !filtered.length) return;
          if (e.key === 'ArrowDown') { e.preventDefault(); setIdx(i => Math.min(i+1, filtered.length-1)); }
          else if (e.key === 'ArrowUp') { e.preventDefault(); setIdx(i => Math.max(i-1, 0)); }
          else if (e.key === 'Enter' && idx >= 0) { e.preventDefault(); select(filtered[idx]); }
          else if (e.key === 'Escape') setOpen(false);
        }} />
      {open && filtered.length > 0 && (
        <div className="autocomplete-dropdown">
          {filtered.map((r, i) => (
            <div key={r.slug} className={`autocomplete-item ${i === idx ? 'active' : ''}`}
              onClick={() => select(r)} onMouseEnter={() => setIdx(i)}>
              {highlight(r.name)}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

function ThemeToggle({ theme, onToggle }) {
  return (
    <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
      <span className="theme-toggle-label">‚òÄÔ∏è</span>
      <div className={`theme-toggle ${theme}`} onClick={onToggle} />
      <span className="theme-toggle-label">üåô</span>
    </div>
  );
}

function StarBadge({ stars }) {
  return <span className={`star-badge star-${stars}`}>{'‚òÖ'.repeat(stars)}{'‚òÜ'.repeat(3-stars)}</span>;
}

function DungeonRunRow({ run, index }) {
  return (
    <div className="dungeon-row fade-in" style={{ animationDelay: `${index*0.04}s` }}>
      <img className="dungeon-thumb" src={run.icon} alt={run.dungeon}
        onError={e => { if (!e.target.dataset.errored) { e.target.dataset.errored = 'true'; e.target.src = `https://via.placeholder.com/48x48/2c2d33/5b9cf5?text=${encodeURIComponent(run.short||'?')}`; } }} />
      <div className="dungeon-info">
        <div className="dungeon-name">{run.dungeon} <span className="key-level-badge">+{run.keyLevel}</span></div>
        <div className="dungeon-meta">
          <StarBadge stars={run.stars} />
          <span className="time-info">~{formatTime(run.estTime)} / {formatTime(run.timerLimit)}</span>
        </div>
        <div className="affix-badges" style={{ marginTop: 4 }}>
          {(run.affixes||[]).map((a,i) => <span key={i} className="affix-badge">{a}</span>)}
        </div>
      </div>
      <div className="dungeon-score-col">
        <div className="dungeon-score score-delta">+{run.scoreGain}</div>
        <div className="dungeon-score-label">score gain</div>
      </div>
    </div>
  );
}

function PathResults({ path, label, desc }) {
  if (!path?.length) return (
    <div className="card" style={{ marginBottom:16, textAlign:'center', padding:32 }}>
      <div style={{ color:'var(--text-muted)', fontSize:14 }}>No path found. Try adjusting filters.</div>
    </div>
  );
  const tg = path.reduce((s,r) => s+r.scoreGain, 0);
  const tt = path.reduce((s,r) => s+r.estTime, 0);
  const ak = (path.reduce((s,r) => s+r.keyLevel, 0)/path.length).toFixed(1);
  return (
    <div className="card fade-in" style={{ marginBottom:16 }}>
      <div style={{ marginBottom:16 }}>
        <div style={{ fontSize:15, fontWeight:600, marginBottom:4 }}>{label}</div>
        <div style={{ fontSize:12, color:'var(--text-muted)' }}>{desc}</div>
      </div>
      <div className="path-summary">
        <div className="path-stat"><div className="path-stat-value">+{tg}</div><div className="path-stat-label">Total Gain</div></div>
        <div className="path-divider" />
        <div className="path-stat"><div className="path-stat-value">{path.length}</div><div className="path-stat-label">Dungeons</div></div>
        <div className="path-divider" />
        <div className="path-stat"><div className="path-stat-value">~{formatTime(tt)}</div><div className="path-stat-label">Est. Time</div></div>
        <div className="path-divider" />
        <div className="path-stat"><div className="path-stat-value">+{ak}</div><div className="path-stat-label">Avg Key</div></div>
      </div>
      {path.map((r,i) => <DungeonRunRow key={i} run={r} index={i} />)}
    </div>
  );
}

function PrivacyModal({ onClose }) {
  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={e => e.stopPropagation()}>
        <h2>üç™ Privacy Policy ‚Äî Cookie Usage</h2>
        <p><strong>What we store:</strong> When you save a search, we store the character name, realm, region, target score, and constraint settings in a browser cookie on your device.</p>
        <p><strong>What we do NOT store:</strong> No personal information, email addresses, IP addresses, or analytics data. No login system, tracking, or third-party sharing.</p>
        <p><strong>How cookies work here:</strong> A single cookie (<code>syrmplus_searches</code>) remembers your past searches so you can quickly re-run them. It is stored entirely on YOUR device.</p>
        <p><strong>No server storage:</strong> All data stays in your browser. The only external requests go to the official Blizzard WoW API.</p>
        <p><strong>Deleting your data:</strong> Use "Clear All" in Saved Searches, or clear cookies in your browser settings.</p>
        <p><strong>Duration:</strong> Cookies expire after 90 days.</p>
        <p style={{ marginTop:16, paddingTop:12, borderTop:'1px solid var(--border)' }}><em>Last updated: {new Date().toLocaleDateString()}</em></p>
        <div style={{ marginTop:20, textAlign:'right' }}><button className="btn btn-primary" onClick={onClose}>Got it</button></div>
      </div>
    </div>
  );
}

function App() {
  const [theme, setTheme] = useState('dark');
  const [charName, setCharName] = useState('');
  const [realm, setRealm] = useState('');
  const [region, setRegion] = useState('us');
  const [targetScore, setTargetScore] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [charData, setCharData] = useState(null);
  const [dungeonState, setDungeonState] = useState(null);
  const [results, setResults] = useState(null);
  const [activeTab, setActiveTab] = useState('quickest');
  const [seasonName, setSeasonName] = useState('');
  const [currentSeasonId, setCurrentSeasonId] = useState(null);
  const [allowedDungeons, setAllowedDungeons] = useState([]);
  const [maxKeyLevel, setMaxKeyLevel] = useState('');
  const [advancedMode, setAdvancedMode] = useState(false);
  const [keystones, setKeystones] = useState([{ slug:'', level:'' }]);
  const [savedSearches, setSavedSearches] = useState([]);
  const [showPrivacy, setShowPrivacy] = useState(false);
  const [showSaved, setShowSaved] = useState(false);
  const [showConstraints, setShowConstraints] = useState(false);
  const [realmsData, setRealmsData] = useState({ us:[], eu:[], kr:[], tw:[] });
  const [realmsLoading, setRealmsLoading] = useState(true);
  const [dungeonList, setDungeonList] = useState(FALLBACK_DUNGEONS);

  useEffect(() => { document.body.setAttribute('data-theme', theme); }, [theme]);
  useEffect(() => { setSavedSearches(loadFromCookies()); }, []);

  // Fetch realm lists and current season dungeons from Blizzard API on mount
  useEffect(() => {
    async function go() {
      setRealmsLoading(true);

      // Fetch realms for all regions
      const nd = { us:[], eu:[], kr:[], tw:[] };
      for (const r of ['us','eu','kr','tw']) {
        try {
          const host = BLIZZARD_API_HOSTS[r];
          const data = await fetchBlizzardApi(`https://${host}/data/wow/realm/index?namespace=dynamic-${r}&locale=en_US`);
          if (data.realms && data.realms.length) {
            nd[r] = data.realms
              .filter(x => x.name && x.slug
                && !/inst|auxiliary|test|tournament/i.test(x.name)
                && !/inst|auxiliary|test|tournament/i.test(x.slug)
                && !/^\d/.test(x.slug)
                && !/[A-Z]{2}\d/.test(x.name))
              .map(x => ({ name: x.name, slug: x.slug }))
              .sort((a,b) => a.name.localeCompare(b.name));
          }
        } catch(e) {
          console.log(`Failed to fetch ${r} realms:`, e);
        }
        if (!nd[r] || nd[r].length === 0) nd[r] = FALLBACK_REALMS[r] || [];
      }
      setRealmsData(nd);

      // Fetch current season dungeon list dynamically
      try {
        const result = await fetchCurrentSeasonDungeons();
        if (result?.dungeons?.length) {
          setDungeonList(result.dungeons);
          if (result.seasonId) {
            setCurrentSeasonId(result.seasonId);
            setSeasonName(getSeasonDisplayName(result.seasonId));
          }
          console.log(`Loaded ${result.dungeons.length} dungeons for season ${result.seasonId}:`, result.dungeons.map(d => d.name));
        }
      } catch(e) {
        console.log('Using fallback dungeon list:', e);
      }

      setRealmsLoading(false);
    }
    go();
  }, []);

  const toggleTheme = () => setTheme(t => t==='dark'?'light':'dark');
  const toggleDungeon = (slug) => setAllowedDungeons(p => p.includes(slug)?p.filter(s=>s!==slug):[...p,slug]);
  const addKeystone = () => setKeystones(p => [...p, {slug:'',level:''}]);
  const removeKeystone = (i) => setKeystones(p => p.filter((_,x)=>x!==i));
  const updateKeystone = (i,f,v) => setKeystones(p => p.map((k,x)=>x===i?{...k,[f]:v}:k));

  const getRealmSlug = (name) => {
    const rl = realmsData[region]||[];
    const f = rl.find(r => r.name.toLowerCase() === name.trim().toLowerCase());
    return f ? f.slug : name.trim().toLowerCase().replace(/'/g,'').replace(/\s+/g,'-');
  };

  async function lookupCharacter() {
    if (!charName.trim() || !realm.trim()) { setError('Please enter both character name and realm.'); return; }
    setLoading(true); setError(''); setCharData(null); setDungeonState(null); setResults(null);
    try {
      const slug = getRealmSlug(realm);
      const name = charName.trim().toLowerCase();
      const host = BLIZZARD_API_HOSTS[region];
      const ns = `profile-${region}`;

      // Fetch character profile
      const profile = await fetchBlizzardApi(
        `https://${host}/profile/wow/character/${encodeURIComponent(slug)}/${encodeURIComponent(name)}?namespace=${ns}&locale=en_US`
      );

      // Fetch M+ keystone profile to get current rating and season list
      let mpProfile = null;
      try {
        mpProfile = await fetchBlizzardApi(
          `https://${host}/profile/wow/character/${encodeURIComponent(slug)}/${encodeURIComponent(name)}/mythic-keystone-profile?namespace=${ns}&locale=en_US`
        );
      } catch(e) { console.log('No M+ profile:', e); }

      // Get the current/latest season's best runs
      let seasonData = null;
      let charSeasonId = null;

      // Log available seasons for debugging
      if (mpProfile?.seasons?.length) {
        const seasonIds = mpProfile.seasons.map(s => s.id);
        console.log('[debug] Character has M+ data for seasons:', seasonIds);
        console.log('[debug] App current season ID:', currentSeasonId);

        // Prefer the known current season if the character has data for it
        if (currentSeasonId && seasonIds.includes(currentSeasonId)) {
          charSeasonId = currentSeasonId;
        } else {
          // Otherwise pick the highest season ID (most recent)
          charSeasonId = Math.max(...seasonIds);
        }
        console.log('[debug] Using season ID:', charSeasonId);
      }
      if (charSeasonId) {
        try {
          seasonData = await fetchBlizzardApi(
            `https://${host}/profile/wow/character/${encodeURIComponent(slug)}/${encodeURIComponent(name)}/mythic-keystone-profile/season/${charSeasonId}?namespace=${ns}&locale=en_US`
          );
          console.log('[debug] Season data best_runs count:', seasonData?.best_runs?.length);
          if (seasonData?.best_runs?.length) {
            console.log('[debug] Best runs dungeons:', seasonData.best_runs.map(r => r.dungeon?.name));
          }
        } catch(e) { console.log('Failed to fetch season data:', e); }
      }

      // Fetch character media for avatar
      let mediaData = null;
      try {
        mediaData = await fetchBlizzardApi(
          `https://${host}/profile/wow/character/${encodeURIComponent(slug)}/${encodeURIComponent(name)}/character-media?namespace=${ns}&locale=en_US`
        );
      } catch(e) { console.log('No character media:', e); }

      // Transform into app-compatible format
      const avatarAsset = mediaData?.assets?.find(a => a.key === 'avatar');
      const mpRating = seasonData?.mythic_rating?.rating || mpProfile?.current_mythic_rating?.rating || 0;

      const charInfo = {
        name: profile.name,
        realm: profile.realm?.name || realm,
        region: region,
        class: profile.character_class?.name || '',
        active_spec_name: profile.active_spec?.name || '',
        thumbnail_url: avatarAsset?.value || null,
        mythic_plus_scores_by_season: [{ season: `season-${charSeasonId || 'current'}`, scores: { all: mpRating } }],
      };
      setCharData(charInfo);
      if (charSeasonId) setSeasonName(getSeasonDisplayName(charSeasonId));

      // Build dungeon state from best runs, using the already-loaded dungeon list
      const bestRuns = seasonData?.best_runs || [];
      setDungeonState(buildDungeonState(bestRuns, dungeonList));
    } catch(e) {
      if (e.message?.includes('NetworkError') || e.message?.includes('Failed to fetch') || (e.name==='TypeError' && e.message?.includes('fetch')))
        setError('Network error ‚Äî make sure python server.py is running with Blizzard API credentials.');
      else setError(e.message || 'Failed to look up character.');
    } finally { setLoading(false); }
  }

  function calculatePaths() {
    if (!dungeonState) return;
    const t = parseInt(targetScore)||0, c = charData?.mythic_plus_scores_by_season?.[0]?.scores?.all || 0;
    if (t <= c) { setError('Target score must be higher than current score.'); return; }
    setError('');
    const con = { allowedDungeons:allowedDungeons.length?allowedDungeons:null, maxKeyLevel:maxKeyLevel?parseInt(maxKeyLevel):null, useKeystones:advancedMode };
    const ks = advancedMode ? keystones.filter(k=>k.slug&&k.level).map(k=>({slug:k.slug,level:parseInt(k.level)})) : null;
    setResults(findPaths(dungeonState, t, c, con, ks));
    setActiveTab('quickest');
  }

  function saveSearch() {
    const s = { id:Date.now(), charName:charName.trim(), realm:realm.trim(), region, targetScore, allowedDungeons:[...allowedDungeons], maxKeyLevel, advancedMode, keystones:advancedMode?[...keystones]:[], savedAt:new Date().toISOString() };
    const u = [s,...savedSearches].slice(0,10); setSavedSearches(u); saveToCookies(u);
  }
  function loadSearch(s) {
    setCharName(s.charName); setRealm(s.realm); setRegion(s.region);
    setTargetScore(s.targetScore||''); setAllowedDungeons(s.allowedDungeons||[]);
    setMaxKeyLevel(s.maxKeyLevel||''); setAdvancedMode(s.advancedMode||false);
    setKeystones(s.keystones?.length?s.keystones:[{slug:'',level:''}]); setShowSaved(false);
  }
  function deleteSaved(id) { const u=savedSearches.filter(s=>s.id!==id); setSavedSearches(u); saveToCookies(u); }
  function clearAllSaved() { setSavedSearches([]); clearCookies(); }

  const cs = charData?.mythic_plus_scores_by_season?.[0]?.scores?.all||0;
  const av = charData?.thumbnail_url;

  const formatSeasonName = (s) => {
    if (!s) return '';
    // Handle both "TWW Season 2" and "season-tww-2" formats
    if (s.startsWith('TWW')) return s;
    return s.replace(/-/g,' ').replace('season tww ','TWW Season ').replace('season df ','DF Season ').replace('season ','Season ').replace(/\b\w/g,c=>c.toUpperCase());
  };

  return (
    <div>
      <header className="header">
        <div className="container header-inner">
          <div className="logo">
            <div className="logo-icon">S</div>
            <h1><span>Syr's</span> M+ Score Goal Helper</h1>
          </div>
          <div className="header-actions">
            <button className="btn btn-ghost btn-sm" onClick={()=>setShowSaved(!showSaved)}>üìã Saved ({savedSearches.length})</button>
            <ThemeToggle theme={theme} onToggle={toggleTheme} />
          </div>
        </div>
      </header>
      <main className="container">
        <div className="section">
          <div className="card">
            <div style={{ display:'flex', alignItems:'center', justifyContent:'space-between', marginBottom:16 }}>
              <div className="section-title" style={{ margin:0 }}><div className="dot" /> Character Lookup</div>
              {seasonName && <div className="season-badge">üè∞ {formatSeasonName(seasonName)}</div>}
            </div>
            <div className="search-grid">
              <div className="input-group">
                <label>Character Name</label>
                <input className="input" placeholder="e.g. Syrsjr" value={charName}
                  onChange={e=>setCharName(e.target.value)} onKeyDown={e=>e.key==='Enter'&&lookupCharacter()} />
              </div>
              <RealmAutocomplete value={realm} onChange={setRealm} region={region} realmsData={realmsData} />
              <div className="input-group">
                <label>Region</label>
                <select value={region} onChange={e=>setRegion(e.target.value)}>
                  {REGIONS.map(r=><option key={r.value} value={r.value}>{r.label}</option>)}
                </select>
              </div>
              <button className="btn btn-primary" onClick={lookupCharacter} disabled={loading} style={{alignSelf:'end'}}>
                {loading?'...':'Look Up'}
              </button>
            </div>
            {realmsLoading && <div className="info-msg" style={{marginTop:12}}>Loading realm lists from Blizzard API...</div>}
            {charData && (
              <div className="target-row">
                <div className="input-group">
                  <label>Target M+ Score</label>
                  <input className="input mono" type="number" placeholder="e.g. 2500" value={targetScore} onChange={e=>setTargetScore(e.target.value)} />
                </div>
                <div style={{ display:'flex', gap:8, alignItems:'flex-end', flexWrap:'wrap' }}>
                  <button className="btn btn-primary" onClick={calculatePaths} disabled={!targetScore}>Calculate Paths</button>
                  <button className="btn btn-secondary" onClick={saveSearch}>üíæ Save</button>
                  <button className="btn btn-ghost btn-sm" onClick={()=>setShowConstraints(!showConstraints)}>
                    ‚öôÔ∏è {showConstraints?'Hide':'Filters'}
                  </button>
                </div>
              </div>
            )}
            {showConstraints && charData && (
              <div style={{ marginTop:20, paddingTop:16, borderTop:'1px solid var(--border)' }}>
                <div className="constraints-grid">
                  <div>
                    <div style={{ fontSize:13, fontWeight:500, color:'var(--text-secondary)', marginBottom:8 }}>
                      Limit to Dungeons <span style={{ fontSize:11, color:'var(--text-muted)' }}>(leave unchecked for all)</span>
                    </div>
                    <div className="dungeon-checkboxes">
                      {dungeonList.map(d=>(
                        <label key={d.slug} className="checkbox-label">
                          <input type="checkbox" checked={allowedDungeons.includes(d.slug)} onChange={()=>toggleDungeon(d.slug)} />
                          {d.short||d.name}
                        </label>
                      ))}
                    </div>
                  </div>
                  <div>
                    <div className="input-group">
                      <label>Max Key Level</label>
                      <input className="input mono" type="number" placeholder="No limit" value={maxKeyLevel} onChange={e=>setMaxKeyLevel(e.target.value)} min="2" max="40" />
                    </div>
                    <div className="toggle-row">
                      <input type="checkbox" checked={advancedMode} onChange={e=>setAdvancedMode(e.target.checked)} style={{accentColor:'var(--accent)'}} />
                      <span className="toggle-label">Advanced: Use Group Keystones</span>
                    </div>
                    {advancedMode && (
                      <div style={{marginTop:12}}>
                        <div style={{fontSize:12,color:'var(--text-muted)',marginBottom:8}}>Enter your group's available keystones:</div>
                        {keystones.map((k,i)=>(
                          <div key={i} className="keystone-grid">
                            <select value={k.slug} onChange={e=>updateKeystone(i,'slug',e.target.value)}>
                              <option value="">Select dungeon...</option>
                              {dungeonList.map(d=><option key={d.slug} value={d.slug}>{d.short||d.name}</option>)}
                            </select>
                            <input className="input mono" type="number" placeholder="+Lvl" value={k.level} onChange={e=>updateKeystone(i,'level',e.target.value)} min="2" max="40" />
                            <button className="btn btn-ghost btn-sm" onClick={()=>removeKeystone(i)}>‚úï</button>
                          </div>
                        ))}
                        <button className="btn btn-secondary btn-sm" onClick={addKeystone} style={{marginTop:4}}>+ Add Key</button>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
        {error && <div className="error-msg" style={{marginBottom:24}}>{error}</div>}
        {loading && <div className="loading-spinner" />}
        {charData && !loading && (
          <div className="section fade-in">
            <div className="card current-score-card">
              {av && <img className="avatar" src={av} alt="avatar" onError={e=>{e.target.style.display='none';}} />}
              <div className="char-details">
                <div className="char-name">{charData.name}</div>
                <div className="char-realm">{charData.realm} ‚Äî {charData.region?.toUpperCase()}</div>
                <div className="char-class">
                  {charData.active_spec_name} {charData.class}
                  {charData.gear?.item_level_equipped?` ‚Ä¢ ${charData.gear.item_level_equipped} ilvl`:''}
                </div>
              </div>
              <div className="current-score-display">
                <div className="current-score-num" style={{color:getScoreColor(cs)}}>{cs.toFixed(1)}</div>
                <div className="current-score-label">Current M+ Score</div>
              </div>
            </div>
          </div>
        )}
        {charData && !loading && (
          <div className="results-layout">
            <div className="results-main">
              {results ? (
                <div className="section fade-in">
                  <div className="section-title"><div className="dot" /> Paths to {targetScore} Score</div>
                  <div style={{marginBottom:4,fontSize:13,color:'var(--text-muted)'}}>
                    Need <strong style={{color:'var(--success)'}}>+{(parseInt(targetScore)-cs).toFixed(0)}</strong> more score
                  </div>
                  <div className="tabs">
                    <button className={`tab ${activeTab==='quickest'?'active':''}`} onClick={()=>setActiveTab('quickest')}>‚ö° Quickest</button>
                    <button className={`tab ${activeTab==='balanced'?'active':''}`} onClick={()=>setActiveTab('balanced')}>‚öñÔ∏è Balanced</button>
                    <button className={`tab ${activeTab==='easiest'?'active':''}`} onClick={()=>setActiveTab('easiest')}>üåø Easiest</button>
                  </div>
                  {activeTab==='quickest'&&<PathResults path={results.quickest} label="‚ö° Quickest Path" desc="Fewest runs ‚Äî max score gain per dungeon" />}
                  {activeTab==='balanced'&&<PathResults path={results.balanced} label="‚öñÔ∏è Balanced Path" desc="Best score gain to key difficulty ratio" />}
                  {activeTab==='easiest'&&<PathResults path={results.easiest} label="üåø Easiest Path" desc="Lowest keys possible ‚Äî may need more runs" />}
                </div>
              ) : (
                <div className="card" style={{textAlign:'center',padding:32,color:'var(--text-muted)',fontSize:14}}>
                  Set a target score above and click "Calculate Paths" to see recommendations.
                </div>
              )}
            </div>
            {dungeonState && (
              <div className="results-sidebar">
                <div className="section-title" style={{marginBottom:8}}><div className="dot" /> Current Scores</div>
                {Object.values(dungeonState).map((d,i)=>(
                  <div key={d.slug} className="compact-dungeon-row fade-in" style={{animationDelay:`${i*0.03}s`}}>
                    <img className="compact-dungeon-thumb" src={d.icon} alt={d.name}
                      onError={e=>{if(!e.target.dataset.errored){e.target.dataset.errored='true';e.target.src=`https://via.placeholder.com/36x36/2c2d33/5b9cf5?text=${encodeURIComponent(d.short)}`;}}}/>
                    <div className="compact-dungeon-info">
                      <span className="compact-dungeon-name">{d.name}</span>
                      <div className="compact-dungeon-meta">
                        {d.best.keyLevel>0 ? (
                          <React.Fragment>
                            <span className="compact-key-level">+{d.best.keyLevel}</span>
                            {d.best.stars>0&&<span className="compact-stars">{'‚òÖ'.repeat(d.best.stars)}</span>}
                          </React.Fragment>
                        ) : (
                          <span style={{color:'var(--text-muted)',fontSize:11}}>‚Äî</span>
                        )}
                      </div>
                    </div>
                    <span className="compact-score" style={{color:getScoreColor(d.totalScore*8)}}>{d.totalScore}</span>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}
        {showSaved && (
          <div className="section fade-in">
            <div className="card">
              <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',marginBottom:16}}>
                <div className="section-title" style={{margin:0}}><div className="dot" /> Saved Searches</div>
                {savedSearches.length>0&&<button className="btn btn-danger btn-sm" onClick={clearAllSaved}>Clear All</button>}
              </div>
              {savedSearches.length===0 ? (
                <div style={{textAlign:'center',padding:24,color:'var(--text-muted)',fontSize:14}}>No saved searches yet.</div>
              ) : (
                <div className="saved-list">
                  {savedSearches.map(s=>(
                    <div key={s.id} className="saved-item" onClick={()=>loadSearch(s)}>
                      <div>
                        <div className="saved-item-name">{s.charName} ‚Äî {s.realm} ({s.region.toUpperCase()})</div>
                        <div className="saved-item-meta">Target: {s.targetScore||'‚Äî'} ‚Ä¢ {new Date(s.savedAt).toLocaleDateString()}</div>
                      </div>
                      <button className="btn btn-ghost btn-sm" onClick={e=>{e.stopPropagation();deleteSaved(s.id);}}>‚úï</button>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        )}
      </main>
      <footer className="footer">
        <p>Syr's M+ Score Goal Helper ‚Äî Data from <a href="https://develop.battle.net/" target="_blank" rel="noopener noreferrer">Blizzard WoW API</a> ‚Ä¢ <a onClick={()=>setShowPrivacy(true)}>Privacy Policy</a></p>
        <p style={{marginTop:4}}>Score calculations are approximate. Dungeon list and season update automatically from the API.</p>
      </footer>
      {showPrivacy && <PrivacyModal onClose={()=>setShowPrivacy(false)} />}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('app')).render(<App />);
</script>
</body>
</html>
